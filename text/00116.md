# Паттерн Фабричная Функция и Модуль

### Что не так с конструкторами?

Конструктор Объектов - один из миллиона способов организовать ваш код. Он довольно распространен и является фундаментальным строительным блоком языка JavaScript.

_Тем не мение..._

Есть много людей, которые выступают _против_ использования конструкторов. Их аргументы сводятся к тому, что если вы не будете осторожны, то есть высокий риск появления багов. [Эта](https://tsherif.wordpress.com/2013/08/04/constructors-are-bad-for-javascript/) статья довольно неплохо описывает проблемы (внутри спойлер: автор заканчивает тем, что рекомендует Фабричная Функция).

Одна из самых больших проблем с конструкторами заключается в том, что они **выглядят** как обычные функции, но не ведут себя как они. Если вы попытаетесь использовать функцию конструктора без ключевого слова `new`, ваша программа не будет работать должным образом, но она не будет выдавать сообщения об ошибках, которые легко отследить.

Вывод заключается в том, что конструкторы не являются _злом_, но они и не являются единственным лучшим способом создания объекта. Конечно, это не значит, что мы потратили время впустую! Конструктор объекта является стандартным шаблоном в коде, в тексте многих учебниках.

#### Встречайте Фабричная Функция

Паттерн Фабричная Функция похож на Конструктор Объекта, но вместо того, чтобы использовать `new` для создания объекта, используют обычный вызов метода. Посмотрим данный пример.

```javascript
const personFactory = (name, age) => {
  const sayHello = () => console.log("Привет!");
  return { name, age, sayHello };
};

const piter = personFactory("Петр", 27);

console.log(piter.name); // 'Петр'

piter.sayHello(); // Вызов функции выводит 'Привет!'
```

для справки, то же самое, только с использованием паттерна Конструктор:

```javascript
const Person = function(name, age) {
  this.sayHello = () => console.log("Привет!");
  this.name = name;
  this.age = age;
};

const piter = new Person("Петр", 27);

console.log(piter.name); // 'Петр'

piter.sayHello(); // Вызов функции выводит 'Привет!'
```

#### Компактный объект

Краткое примечание о строке 3 из примера с Фабричной Функцией. В 2015 году в JavaScript был добавлен новый удобный способ создания объектов. Без сокращения строка 3 выглядела бы так:

```javascript
return { name: name, age: age, sayHello: sayHello };
```

Проще говоря, если вы создаете объект, в котором вы ссылаетесь на переменную, имя которой совпадает с именем создаваемого вами свойства, вы можете сократить его:

```javascript
return { name, age, sayHello };
```

Зная это, давайте глянем на небольшой хак:

```javascript
const name = "Влад";
const color = "красный";
const number = 34;
const food = "рис";

// вам может быть необходимо вывести все эти переменные,
// но вы не увидите имя полей и соответсвтенно можете запутаться.
console.log(name, color, number, food); // Влад красный 34 рис

// если же вы обернете их в объект,
// то вывод будет намного понятнее.
console.log({ name, color, number, food });
// { name: 'Влад', color: 'красный', number: 34, food: 'рис' }
```

### Область видимости и замыкание

Изучив приведенный выше пример, вы можете без проблем использовать фабричные функции в своем коде, но прежде чем мы перейдем к этому, пришло время немного углубиться в невероятно важную концепцию: **замыкание**.

Прежде чем мы сможем понять смысл замыкания, мы должны убедиться, что вы _знаете_ что такое **область видимости** в JavaScript. Область видимости определяет, где ваши переменные и функции, могут использоваться в коде.

Знаете ли вы, какой будет вывод в последней строке данного ниже примера?

```javascript
let a = 17;

const func = x => {
  let a = x;
};

func(99);

console.log(a); // ???????
```
