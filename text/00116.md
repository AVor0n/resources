# Паттерн Фабричная Функция и Модуль

### Что не так с конструкторами?

Конструктор Объектов - один из миллиона способов организовать ваш код. Он довольно распространен и является фундаментальным строительным блоком языка JavaScript.

_Тем не мение..._

Есть много людей, которые выступают _против_ использования конструкторов. Их аргументы сводятся к тому, что если вы не будете осторожны, то есть высокий риск появления багов. [Эта](https://tsherif.wordpress.com/2013/08/04/constructors-are-bad-for-javascript/) статья довольно неплохо описывает проблемы (внутри спойлер: автор заканчивает тем, что рекомендует Фабричная Функция).

Одна из самых больших проблем с конструкторами заключается в том, что они **выглядят** как обычные функции, но не ведут себя как они. Если вы попытаетесь использовать функцию конструктора без ключевого слова `new`, ваша программа не будет работать должным образом, но она не будет выдавать сообщения об ошибках, которые легко отследить.

Вывод заключается в том, что конструкторы не являются _злом_, но они и не являются единственным способом создания объекта. Конечно, это не значит, что мы потратили время впустую! Конструктор объекта является стандартным паттерном (шаблоном) в коде и в тексте многих учебников.

#### Встречайте Фабричная Функция

Паттерн Фабричная Функция похож на Конструктор Объекта, но вместо того, чтобы использовать `new` для создания объекта, используют обычный вызов метода. Посмотрим данный пример.

```javascript
const personFactory = (name, age) => {
  const sayHello = () => console.log("Привет!");
  return { name, age, sayHello };
};

const piter = personFactory("Петр", 27);

console.log(piter.name); // 'Петр'

piter.sayHello(); // Вызов функции выводит 'Привет!'
```

для справки, то же самое, только с использованием паттерна Конструктор:

```javascript
const Person = function(name, age) {
  this.sayHello = () => console.log("Привет!");
  this.name = name;
  this.age = age;
};

const piter = new Person("Петр", 27);

console.log(piter.name); // 'Петр'

piter.sayHello(); // Вызов функции выводит 'Привет!'
```

#### Компактный объект

Краткое примечание о строке 3 из примера с Фабричной Функцией. В 2015 году в JavaScript был добавлен новый удобный способ создания объектов. Без сокращения строка 3 выглядела бы так:

```javascript
return { name: name, age: age, sayHello: sayHello };
```

Проще говоря, если вы создаете объект, в котором вы ссылаетесь на переменную, имя которой совпадает с именем создаваемого вами свойства, вы можете сократить его:

```javascript
return { name, age, sayHello };
```

Зная это, давайте глянем на небольшой хак:

```javascript
const name = "Влад";
const color = "красный";
const number = 34;
const food = "рис";

// вам может быть необходимо вывести все эти переменные,
// но вы не увидите имя полей и соответсвтенно можете запутаться.
console.log(name, color, number, food); // Влад красный 34 рис

// если же вы обернете их в объект,
// то вывод будет намного понятнее.
console.log({ name, color, number, food });
// { name: 'Влад', color: 'красный', number: 34, food: 'рис' }
```

### Область видимости и замыкание

Изучив приведенный выше пример, вы можете без проблем использовать фабричные функции в своем коде, но прежде чем мы перейдем к этому, пришло время немного углубиться в невероятно важную концепцию: **замыкание**.

Прежде чем мы сможем понять смысл замыкания, мы должны убедиться, что вы _знаете_ что такое **область видимости** в JavaScript. Область видимости определяет, где ваши переменные и функции, могут использоваться в коде.

Знаете ли вы, какой будет вывод в последней строке данного ниже примера?

```javascript
let a = 17;

const func = x => {
  let a = x;
};

func(99);

console.log(a); // ???????
```

17 или 99? Знаете почему? Можете ли вы отредактировать код так, чтобы он печатал другое значение?

Ответ 17. Причина в том, что в строке 4 внешняя переменная `a` не переопределена, а _новая_` a` создается внутри области видимости этой функции. В конце концов, определить область видимости в большинстве случаев не так уж сложно, но важно понять некоторые концепции, поэтому не торопитесь при изучении данного урока.

1. [Это](https://www.youtube.com/watch?v=SBwoFkRjZvE) и [это видео на русском](https://www.youtube.com/watch?v=zgrABxxY3XA) просто и понятно объясняет материал! Начните здесь.

2. [Эта статья](https://habr.com/ru/post/239863/) начинается с простого и повторяет содержание видео, но углубляется и более конкретно описывает терминологию. В конце рассказывается о __замыкании__ и описывается шаблон __модуль__, о котором мы поговорим позже.

> Предыдущая статья великолепна, но есть одно неточное утверждение:
> 
> "Все локальные ОВ создаются только в функциональных ОВ, они не создаются циклами типа `for` или `while` или директивами типа `if` или `switch`. Новая функция – новая область видимости."
>
> Это утверждение `было` верным в 2013 году, когда статья была написана, но на текущий момент нет благодаря ES6. Прочитайте [эту](http://wesbos.com/javascript-scoping/) статью или [эту на русском](https://medium.com/nuances-of-programming/%D0%B2-%D1%87%D1%91%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-var-let-%D0%B8-const-%D0%B2-javascript-3084bfe9f7a3), чтобы получить больше информации!

### Частные переменные и функции

Теперь, когда мы закрепили ваши знания в области JavaScript, взглянем на этот пример:

~~~javascript
// Фабричная функция
const FactoryFunction = string => {
  const capitalizeString = () => string.toUpperCase();
  const printString = () => console.log(`----${capitalizeString()}----`);
  return { printString };
};

const taco = FactoryFunction('тако');

printString(); // ERROR!!
capitalizeString(); // ERROR!!
taco.capitalizeString(); // ERROR!!
taco.printString(); // Выведет "----ТАКО----"
~~~

Из-за концепции области видимости, ни одна из функций, созданных внутри `FactoryFunction`, не может быть доступна вне самой функции, поэтому строки 9 и 10 выше выдают ошибку. Единственный способ использовать любую из этих функций - это `вернуть` (или `return`) их в объекте (см. строку 4), поэтому мы можем вызвать `taco.printString()`, но _не_ `taco.capitalizeString()`. Здесь важно то, что _мы_ не можем получить доступ к функции `capitalizeString()`, а `printString()` может. Это замыкание.

Концепция замыкания - это идея о том, что функции сохраняют свою область видимости, даже если они вызываются вне этой области. В этом случае `printString` имеет доступ ко всему, что находится внутри `FactoryFunction`, даже если `printString` вызывается вне `FactoryFunction`.

Вот еще один пример:

~~~javascript
const counterCreator = () => {
  let count = 0;
  return () => {
    console.log(count);
    count++;
  };
};

const counter = counterCreator();

counter(); // 0
counter(); // 1
counter(); // 2
counter(); // 3
~~~

В этом примере `counterCreator` инициализирует локальную переменную (`count`) и возвращает функцию. Чтобы использовать эту функцию, мы должны присвоить ее переменной (строка 9). Затем каждый раз, когда мы запускаем функцию, она выводит (`console.log`) и увеличивает `count`. Как и выше, функция `counter` является замыканием. Она имеет доступ к переменной `count` и может выводить, увеличивать ее. У нашей программы нет другого способа получить доступ к этой переменной.

В контексте Фабричных Функций замыкания позволяют нам создавать приватные (`private`) переменные и функции. Приватные функции - это функции, которые используются в работе наших объектов и не предназначены для использования в других местах нашей программы. Другими словами, если наши объекты могут выполнять только одну или две задачи, мы можем поделить наши функции на более мелкие, что позволит сделать код чище и проще для чтения, и экспортировать только те функции, которые будут вызываться в других частях программы. Используя эту терминологию с нашим примером `printString`, `capitalizeString` является закрытой функцией, а `printString` является публичной.

Концепция приватных функций очень полезна и должна использоваться как можно чаще! В любой части программы будет несколько вспомогательных функций, которые НЕ нужно использовать в вашей программе в целом. Убирая их и делая их недоступными, ваш код легче реорганизовать, тестировать и понять.

### Возвращаемся к Фабричным Функциям

Разобравшись с теорией, вернемся к Фабричным Функциям. Фабрики - это просто старые функции JavaScript (POJSO), которые возвращают объекты. Использование Фабрик - это отличный способ организовать и структурировать код. Например, если мы пишем какую-либо игру, мы, вероятно, захотим, чтобы объекты описывали наших игроков и инкапсулировали (сокрыть) все, что могут делать наши игроки (функции!).

~~~javascript
// Функция создает игрока
const Player = (name, level) => {
  let health = level * 2;
  // возвращает уровень
  const getLevel = () => level;
  // возвращает имя
  const getName  = () => name;
  // смерть
  const die = () => {
    // ох...
  };
  // наносим урон (минусуем жизни)
  const damage = x => {
    health -= x;
    if (health <= 0) {
      die();
    }
  };
  // атакуем
  const attack = enemy => {
    if (level < enemy.getLevel()) {
      damage(1);
      console.log(`${enemy.getName()} has damaged ${name}`);
    }
    if (level >= enemy.getLevel()) {
      enemy.damage(1);
      console.log(`${name} has damaged ${enemy.getName()}`);
    }
  };
  return {attack, damage, getLevel, getName}
};

const vanja = Player('ваня', 10);
const badGuy = Player('петя', 5);
vanja.attack(badGuy);
~~~

Потратьте минуту, чтобы разобрать этот простенький пример. Выясните, что происходит.

Что бы произошло, если бы мы вызвали `vanja.die()`? Что если мы попытаемся манипулировать здоровьем: `vanja.health -= 1000`? Верно, это те вещи, которые мы НЕ выставили наружу, поэтому мы получим ошибку. 
Это очень круто! Создание объектов таким образом упрощает жизнь, потому что мы продумали, как и когда мы будем использовать информацию. 
В результате параметр здоровья (`health`) Вани сокрыт как приватная переменная внутри объекта. Это означает, что нам нужно экспортировать функцию, если мы хотим изменять параметр здоровья. 
В конечном счете, наш код будет `более` понятным, потому что вся логика инкапсулирована в соответствующем месте.

#### Наследование с Фабриками

На уроке конструкторов мы довольно глубоко изучили концепцию прототипов и наследования, или предоставили нашим объектам доступ к методам и свойствам другого объекта. Есть несколько простых способов сделать это, используя фабрики. Проверьте это:

~~~javascript
const Person = (name) => {
  // выводим имя
  const sayName = () => console.log(`Мое имя ${name}!`)
  return {sayName}
}

const Nerd = (name) => {
  // создаем человека и забираем функциию sayName!
  const {sayName} = Person(name)
  const doSomethingNerdy = () => console.log('Задротские штучки')
  return {sayName, doSomethingNerdy}
}

const pasha = Nerd('Паша')

pasha.sayName() // Мое имя Паша!
pasha.doSomethingNerdy() // Задротские штучки
~~~

Этот паттерн _хорош_, потому что он позволяет вам выбирать, какие функции включить в свой новый объект. 
Если вы хотите объединить ВСЕ параметры другого объекта, вы можете сделать это с помощью `Object.assign` (см. документацию по данной функции [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)).

~~~javascript
const Nerd = (name) => {
  const prototype = Person(name)
  const doSomethingNerdy = () => console.log('Задротские штучки')
  return Object.assign({}, prototype, {doSomethingNerdy})
}
~~~

- Прежде чем двигаться дальше, взгляните на [эту](https://medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9) статью. 
Во второй половине статьи автор рассказывает о вещах, о которых мы не говорили, и вы будете вознаграждены, если потратите время на изучение. Отличная статья!

### Шаблон модуля

> Краткое описание: ES6 представила в JavaScript новую функцию под названием **модули**. По сути, это синтаксис для импорта и экспорта кода между различными файлами JavaScript. Они очень круты, и мы будем их освещать позже. **Но эти модули не то, о которых мы говорим тут.**

Модули на самом деле очень похожи на Фабричную Функцию. Главное отличие в том, как они создаются.

Встречайте модуль:

~~~javascript
const calculator = (() => {
  const add = (a, b) => a + b;
  const sub = (a, b) => a - b;
  const mul = (a, b) => a * b;
  const div = (a, b) => a / b;
  return {
    add,
    sub,
    mul,
    div,
  };
})();

calculator.add(3,5) // 8
calculator.sub(6,2) // 4
calculator.mul(14,5534) // 77476
~~~

Концепция точно такая же, как у Фабричной Функции. 
Однако вместо создания Фабрики, которую мы можем использовать снова и снова для создания нескольких объектов, 
шаблон Модуль (Module) оборачивает фабрику в IIFE (немедленно вызываемые функции)).

- Читайте о IIFE в [этой статье](http://adripofjavascript.com/blog/drips/an-introduction-to-iffes-immediately-invoked-function-expressions.html) или [на русском](https://getinstance.info/articles/javascript/immediately-invoked-function-expressions/). Идея проста: написать функцию, обернуть ее в скобки, а затем немедленно вызвать функцию, добавив `()` в конец.

В нашем примере калькулятора функция внутри IIFE является простой Фабричной Функцией, но мы можем просто пойти дальше. Нам не нужно создавать много калькуляторов! Нам нужен только один! 

Как и в примере с Фабрикой, у нас может быть столько закрытых функций и переменных, сколько мы хотим, и они остаются аккуратно организованными, спрятанными внутри нашего модуля. С другой стороны мы раскрываем только те функции, которые мы действительно хотим использовать в нашей программе.

Полезным побочным эффектом инкапсуляции является __пространство имен__ (__namespacing__). Пространство имен - это метод, с помощью которого избегают коллизий имен. 
Например, легко представить сценарий, в котором мы могли бы написать несколько функций с одним и тем же именем. Что если бы в нашем примере выше у нас была функция, которая добавляла элементы на страницу, или функция, которая добавляла числа и операторы в наш стек по мере ввода их пользователями. 
Вполне возможно, что мы захотим вызвать все 3 функции именем `add`, что вызовет проблемы. Если бы все они были красиво инкапсулированы внутри объекта, у нас не было бы проблем: `calculator.add()`, `displayController.add()`, `operatorStack.add()`.
