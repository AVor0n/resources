## Тестирование

### Введение

Модульное тестирование имеет огрмоное значение по причинам, которые мы прям сейчас освещать не будем. Если вы уже прошли траекторию по JavaScript, то сталкивались с модульным тестированием. Цель этого урока не в том, чтобы научить вас философии или механике написания тестов, а в том, как они применяются к приложениям и API-интерфейсам Express.

Если вы еще не закончили наш курс по JavaScript, вернитесь к нему, прежде чем продолжить.

Самое важное требование для тестирования чего-либо в вашем коде - это наличие экспорта. Это верно как для middleware, так и для ваших роутов / контроллеров. Поэтому самое первое, что вам нужно сделать - разделить все на отдельные модули.

В случае роутов (маршрутов) вы уже знаете, как это сделать, используя Express.Router. Ниже приведен очень простой пример:

~~~javascript
//// app.js
const express = require("express");
const app = express();

app.use(express.urlencoded({ extended: false }));

const indexRouter = require("./index");
app.use("/", indexRouter);

app.listen(3000, () => console.log("запущенно"));
~~~

~~~javascript
//// index.js
const express = require("express");
const index = express.Router();

const array = [];

index.get("/", (req, res) => res.json({ name: "Фродо" }));

index.get("/test", (req, res) => res.json({ array }));

index.post("/test", (req, res) => {
  array.push(req.body.item);
  res.send('успех!');
});

module.exports = index;
~~~

Эти два файла `app.js` и` index.js` просто определяют несколько маршрутов. На данный момент нам не нужно тестировать `app.js`, потому что этот код только создает и запускает express-приложение! Он не включает нашей собственной логики, поэтому нам не нужно его проверять. `index.js`, однако, _включает_ в себя то, что мы хотим протестировать.

Чтобы упростить тестирование этих маршрутов, мы будем использовать библиотеку [Supertest](https://github.com/visionmedia/supertest). Добавим ее с помощью команды `npm install supertest` и пока идет установка, просмотрите [readme на их git-репо](https://github.com/visionmedia/supertest).

В приведенных ниже примерах мы будем использовать Supertest внутри блока test. Такой синтаксис распространен в большинстве библиотек тестирования, поэтому данный код без проблем может быть воспроизведен в Mocha с Chai, Jasmine или Tape и т.д.

Вот наш тест:

~~~javascript
const index = require("../index");

const request = require("supertest");
const express = require("express");
const app = express();

app.use(express.urlencoded({ extended: false }));
app.use("/", index);

test("index route works", done => {
  request(app)
    .get("/")
    .expect("Content-Type", /json/)
    .expect({ name: "Фродо" })
    .expect(200, done);
});

test("testing route works", done => {
  request(app)
    .post("/test")
    .type("form")
    .send({ item: "эй" })
    .then(() => {
      request(app)
        .get("/test")
        .expect({ array: ["эй"] }, done);
    });
});
~~~

Теперь шаг за шагом.

Для начала нам нужно импортировать модуль, который мы тестируем, в данном случае это файл `index.js`.

~~~javascript
const index = require("../index");
~~~

Далее мы добавляем `supertest` и `express`. Мы создаем новое express-приложение и добавляем маршрутизатор для индекса, который мы импортировали ранее. Причина, по которой мы должны все это сделать, заключается в том, что мы фактически не трогаем наш исходный файл `app.js`. Связанно это с тем, что мы таким образом избегаем вызова команды `app.listen` и соответственно запуска нашего сервера. Плюс в более крупных приложениях можно пропустить дополнительные шаги конфигурации и добавить только тот код, который нам действительно нужнен для тестирования. При большем количестве тестов, будет полезно вынести (абстрагировать) эту часть в отдельный файл, который добавляется потом в каждый тестовый файл.

~~~javascript
const request = require("supertest");
const express = require("express");
const app = express();

app.use(express.urlencoded({ extended: false }));
app.use("/", index);
~~~

Сами тесты относительно просты благодаря библиотеке Supertest! Помните, что мы импортировали supertest как `request`. Мы вызываем этот объект в нашем вновь созданном express-приложении, проходим по маршруту и ​​затем используем `request` для проверки соответствия ожидаемого содержимого.

Обратите внимание на параметр `done`, который передается в тестовый callback. Большинство библиотек для тестов используют `done`, чтобы сигнализировать о завершении теста в случае запуска асинхронных операций... в нашем примере Supertest позволяет нам передать `done` в `.expect`. Спасибо, Supertest!

~~~javascript
test("маршрут для индекса работает", done => {
  request(app)
    .get("/")
    .expect("Content-Type", /json/)
    .expect({ name: "Фродо" })
    .expect(200, done);
});
~~~

Наш второй тест очень похож на первый, но для метода `post`. Вы должны прочитать обо всех возможных функциях в [README](https://github.com/visionmedia/supertest), поэтому не будем вдаваться в подробности каждого шага. И последнее, что важно для нас. К этому моменту вы должны быть знакомы с Promises (Обещание), поэтому синтаксис `.then()` не будет чем-то новым. Мы ожидаем завершения запроса POST и затем вызываем запрос GET, когда Promise разрешается, чтобы проверить, был ли элемент помещен в массив.

~~~javascript
test("маршрут test работает", done => {
  request(app)
    .post("/test")
    .type("form")
    .send({ item: "эй" })
    .then(() => {
      request(app)
        .get("/test")
        .expect({ array: ["эй"] }, done);
    });
});
~~~

Если бы мы использовали реальную базу данных, то запускали бы тесты, используя либо тестовую, либо фиктивную базу данных. Мы поговорим об этом подробнее в отдельном уроке. Пока достаточно сказать, что вы не захотите запускать тесты в своей production (боевой) базе данных!


### Задание

1. Убедитесь, что вы изучили [доки Supertest](https://github.com/visionmedia/supertest);
2. Supertest фактически основан на Superagent. Любой метод, который вы можете использовать в Superagent, вы можете вызвать и в Supertest. Поэтому гляньте еще [доки SuperAgent](http://visionmedia.github.io/superagent/).
