## Данные

### Созданные с помощью `new`

Для создания примитивов в языке Go используются функции `new` и `make`.
Они разные и применяются для разных типов, это может сбить с толку, но правило очень просто.
Для начала обсудим функцию `new`.
Данная функция резервирует память, но не также как в других языках программирования, она не просто *инициализирует* память, а вместо этого заполняет *нулями*.

К примеру `new(T)` резервирует память нулями для нового элемента типа `T` и возвращает его указатель на значение типа `*T`. В терминологии Go, он возвращает указатель на новую зарезервированную память заполненная нулями с типом `T`.


**TODO**
Since the memory returned by `new` is zeroed, it's helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization.  This means a user of the data structure can create one with `new` and get right to work.
For example, the documentation for `bytes.Buffer` states that "the zero value for `Buffer` is an empty buffer ready to use."
Similarly, `sync.Mutex` does not have an explicit constructor or `Init` method.
Instead, the zero value for a `sync.Mutex` is defined to be an unlocked mutex.
The zero-value-is-useful property works transitively. Consider this type declaration.
**-**

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

**TODO**
Values of type `SyncedBuffer` are also ready to use immediately upon allocation or just declaration.  In the next snippet, both `p` and `v` will work correctly without further arrangement.
**-**

```go
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

### Конструкторы и составные литералы

Иногда нулевых значений не достаточно и необходимо иметь конструктор, следующий пример взят из пакета `os`.

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

Существует много шаблонов. Мы просто можем использовать *составные литералы*, которые будут создавать новые сущности каждый раз.

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

Обратите внимание на то, что в отличии от языка С, это нормально, возвращать адрес локальных переменных, так как переменная уже существует после возвращения из функции.
На самом деле, возвращение адресов составных литералов создает новую сущность каждый раз, как он вычисляется.
Итак мы можем объединить последние две строки:

```go
    return &File{fd, name, nil, 0}
```

Поля составных литералов должны быть в порядке объявления и все должны присутствовать.
Однако, используя маркировку как пара *поле*`:`*значение*, могут инициализироваться в любом порядке, с пропущенными полями заполняемые нулями.
Таким образом, можно объявить:

```go
    return &File{fd: fd, name: name}
```

В предельном случае, когда составной литерал без полей вообще, то создание нулевым значением будет тип. Выражения `new(File)` и `&File{}` одинаковы.


Составные литералы могут также создавать массивы, срезы, карты, с пометкой полей как индексов или ключами карт.
К примеру, инициализированные значения `Enone`, `Eio`, и `Einval` разные.


```go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

### Создание с помощью `make`

Возвращаясь к созданию элементов.
Встроенная функция `make(T, `*args*`)` служит для других целей нежели `new(T)`.
Он создает только срезы, карты и каналы, и возвращают *инициализированные* (не нулевые) значение типа `T` (а не `*T`).
Причиной различия для этих трех типов, в том что внутри они представляют из себя структуры данных, которые необходимо инициализировать перед использованием.
К примеру, срезы - это трехэлементная структура, содержащая указатель на данные(внутри массив), длину, и емкость, причём пока все элементы не инициализированы - срез  *нулевой* `nil`.
Для срезов, карт и каналов, встроенная команда `make` инициализирует внутреннюю структуру данных и подготавливает значения к использованию.

К примеру:

```go
make([]int, 10, 100)
```

создает массив из 100 значений типа `int` и затем создает структуру среза длинной 10 и емкостью 100 со ссылкой только на первые 10 элементов.
(Когда создается слайс, его емкость задавать не обязательно, смотрите раздел посвящённый срезам.)
В противоположность, `new([]int)` возвращает указатель на новый, созданный, заполненный нулями срез, это указатель на значение `nil` среза.

Эти примеры показывают различие между `new` и `make`.


```go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

Помните что `make` используется только для карт, срезов и каналов и не возвращают указатель.
Для получения указателя в явном виде используйте `new` или  возьмите указатель в явном виде.

### Массивы

Массивы популярны когда точно известно необходимое количество памяти, чтобы не делать излишних пересозданий, но в первую очередь они являются составной частью для срезов, о которых будет описано в следующем разделе.

Какие основные отличия между обращением с массивами между языками Go и C:
* Массивы значений. Присвоение одно массива другому копирует все элементы.
* Если вы передаёте массив в функцию, то передаётся копия массива, а не указатель на него.
* Размер массива является частью массива. Типы `[10]int` и `[20]int` разные.

Массивы могут быть полезными, но дорогими(с точки зрения производительности) и если Вы хотите иметь гибкость и эффективность схожее с поведением в языке C-like, то необходимо использовать в функциях указатели.


```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```

Но данный стиль не подходит Go.
Используйте срезы вместо массивов.


### Срезы (Slices, слайсы)

Срезы это обёртка для массивов и при этом более общий и мощный, и предоставляет собой более удобный интерфейс по управлению данными, в случаях, когда не известно точное количество элементов и необходимо преобразование размера массивов.
Большинство программ на языке Go, выполнены с использованием срезов, а не простых массивов.

Срез хранит ссылку на массив и поэтому если приравнять срез к другому срезу, то будет тот же массив.
Если срез является аргументом функции, то изменения элементов в срезе будут видны вызывающему данному функцию, это аналогично передаче указателя на базовый массив.
В функция `Read` может принимать в качестве аргумента срез, что равнозначно указателю на массив и длины массива; длина среза указывает верхний предел количество данных которые необходимо прочитать.
В данном случае тип `File` пакета `os` имеет следующую сигнатуру метода `Read`:

```go
func (f * File) Read(buf []byte) (n int, err error)
```

Метод возвращает количество прочитанных байт или если есть, то ошибку.
Для чтения первых 32 байт в буфере `buf`, *получить(срезать) часть* буфера.

```go
    n, err := f.Read(buf[0:32])
```

Такой срез является эффективным. На самом деле, если оставить в стороне эффективность, то следующий пример показывает чтение первых 32 байт из буфера.

```go
    var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
```

Длина среза может меняться, пока не исчерпает размер внутреннего массива.
С помощью встроенной функции `cap` можно узнать *емкость* среза, представляющий максимальную длину среза.
В следующем примере рассматривается функция для добавления данных в срез.
Если данные превышают ёмкость среза, то срез необходимо переопределить.
Функция `Append` возвращает результирующий срез. Функция использует тот факт что  использование `len` и `cap` допустимо, даже если у нас имеется нулевой срез `nil` - при этом возвращая 0.

```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))* 2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
```


**TODO**
We must return the slice afterwards because, although `Append`
can modify the elements of `slice`, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.
**-**

Добавление элементов в срез настолько популярно, что функция `append` стала встроенной. Для того чтобы понять принцип работы данной функции нам необходимо больше информации, поэтому мы вернёмся к этому позже.

### Двухмерные срезы

Массивы и срезы в Go - одномерные.
Для создания двухмерного массива или среза, нам необходимо определять массив-массивов или срез-срезов, как в примере:

```go
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
```

В связи с тем, что срезы переменной длины, то допустимо иметь каждый внутренний срез разной длины.
Это наиболее общая ситуация, как в примере `LinesOfText`, в котором каждая строка имеет независимую длину.

```go
text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
```

Иногда необходимо создавать двухмерные срезы, к примеру при обработки пикселей.
Есть 2 способа для этого:
  * Первый, создание каждого среза независимо
  * Второй, создание простого массива срезов.
Наилучший способ выбирается в зависимости от программы.
Если срез можно увеличивать или уменьшать, они должны быть независимы, для того чтобы избежать перезаписи новых строк. Если не требуется изменять размер, то наиболее эффективным был бы способ с создание одним их аллоцированием(инициализацией).
Рассмотрим оба способа.

```go
// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
```

с одним созданием:

```go
// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

### Карты(Maps)

Карты - это удобная и мощная встроенная структура данных, связывающая значение одного типа(*ключ (key)*) со значением другого типа (*элемент (element)* или *значение (value)*).
Ключ может быть любого типа, для которого определён оператор равно, как для целых чисел, чисел с плавающей точкой или комплексные числа, строки, указатели, интерфейсы (если динамические типы поддерживают равенство), структуры и массивы.
Срезы не используются в качестве ключа для карт, так как равенство не определено для них.
Карты, также как и срезы, имеют внутреннюю структуру данных.
Если Вы передадите карту в функции и измените содержание карты, то изменения останутся для вызывающего.
Карты могут быть созданы с использованием синтаксиса составных литералов с разделением по колонкам пар ключ-значение, поэтому легко создать начальные данные.

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

Добавление и получение значений из карт, синтаксически, выглядит как для массивов или срезов, за тем исключением того что индекс не обязательно должен быть целым числом.

```go
offset := timeZone["EST"]
```

При попытке получения значения из карты по ключу, которого нет в карте, приведёт к возвращению нулевого значения.
К примеру, если карта содержит целые числа, как описывалось выше, для несуществующего ключа будет возвращено `0`.
Это можно представить как карту у которой в качестве типа значения используется `bool`. Добавление записи в карту это как добавление со значением `true` в карту и дальнейшая простая проверка на индексирование.

```go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
```

Иногда необходимо отличать отсутствие записи от нулевого значения. К примеру, есть ли запись для `"UTC"` или это пустая строка потому что отсутствует значение в карте?
Для того чтобы отличить - Вы можете использовать множественное присвоение.

```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

Очевидная причина называть данную идиому "запятая ок".
В данном примере, если `tz` существует, то `seconds` будет иметь необходимое значение и `ok` будет `true`, но если не существует, то `seconds` будет иметь нулевое значение а `ok` будет `false`.
В следующем примере, представлена функция с хорошим описанием ошибки:

```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

В случаи, если нас не интересует само значение, а лишь его наличие, то можно использовать **пустой идентификатор `_`**, расположенный вместо значения.

```go
_ , present := timeZone[tz]
```

Для удаления записи из карты, необходимо использовать встроенную функцию `delete`, где в качестве аргументов задаётся карта и ключ для удаления.
Данная операция безопасна, даже если данного ключа уже нет в карте.

```go
delete(timeZone, "PDT")  // Now on Standard Time
```

### Печать(Printing)

Форматированная печать в Go подобна стилю в языке C `printf`, но более богаче и более обобщенное. Необходимые функции расположены в пакете `fmt` и имеют названия с большой буквы: `fmt.Printf`, `fmt.Fprintf`, `fmt.Sprintf` и так далее.  Функции (`Sprintf` и другие) возвращают строку, а не заполняют предоставленный буфер.

Вам нет необходимости в создании форматировании строк, так как для каждой  `Printf`, `Fprintf` and `Sprintf` есть пара функций к примеру `Print` и `Println`.

Данные функции не берут формат строки, а вместо этого устанавливают форматирование по умолчанию для каждого аргумента. Функция `Println` также добавляет пробел между аргументами и добавляет разрыв строки в конце строки. Функция `Print` добавляет пробел только той же строке.
В примере каждая строка производит одинаковый результат.

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

Для форматированной печати функцией `fmt.Fprint` и его друзьями, принимают в качестве первого аргумента объект реализующий интерфейс `io.Writer`.
Значения `os.Stdout` и `os.Stderr` знакомы.


Следующее расходится с реализацией на языке С. Первое, числовые форматы `%d` не имеют флагов знаковости или размера; Вместо этого, функции печати используют тип аргумента для задания свойств.

```go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```

печатает

```
18446744073709551615 ffffffffffffffff; -1 -1
```

Если вы используете соглашение по умолчанию, то для целых чисел можно использовать обобщенный формат `%v` (для "значений"); и результат будет одинаков как для  `Print` так и для `Println`.

Более того, данный формат может напечатать *любое* значение, даже срез, структуру или карту.
Печать карты временной зоны из предыдущего раздела.

```go
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
```

который печатает следующий результат

```
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
```

Ключи карт могут быть напечатаны в любом порядке.
При печати структуры, с аннотацией `%+v` производиться печать полей структуры с их именами и для каждого значения с форматом `%#v` печатается значение с полным синтаксисом Go.

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

печатает

```
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
```

(На заметку: обратите внимание на амперсанды)

Для ссылок на строки подходит `%q`, который принимает значение на `string` или `[]byte`.
Альтернативный формат `%#q` будет использовать обратные кавычки, если это возможно.
(Формат `%q` также допустим для целых чисел и рун, создавая односсылочные константы рун.)
Также, `%x` работает со строками, массивом байт и срезом байт также как с целыми числами, создаёт шестнадцатеричные целые строки, а с пробелом в формате (`% x`) добавляет пробелы между байтами.


Другой удобный формат `%T`, который печатает *тип* значения.

```go
fmt.Printf("%T\n", timeZone)
```

печатает

```
map[string] int
```

Если Вы хотите свой собственный формат типа, то для этого достаточно метод с сигнатурой `String() string` для Вашего типа.
Для нашего простого примера, тип `T`, выглядит следующим образом.

```go
func (t * T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

Печатает в следующем формате

```
7/-2.35/"abc\tdef"
```

(Если Вам необходимо напечатать *значение* типа `T` как указателя на тип `T`, то метод `String` должен иметь значение типа; этот пример использует указатель, т.к. они более эффективны и идиоматичны типу структуры.)


Наша функция `String` может вызывать `Sprintf`, потому что функция печати возвращаемая и поэтому можно её обернуть. Это важно для понимания данного подхода.
Однако, не создавайте функцию `String` вызывающую метод `Sprintf`, в случаи если далее будет рекурсивно вызвана `String`.
Это может произойти если `Sprintf` вызывает на печать строку получателя, который вызовет функцию снова. Эту ошибку можно легко создать и она показана на следующем примере.

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
```

Для того чтобы решить эту проблему, необходимо изменить аргумент на базовый тип, который не имеет функции.

```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
```

Другой способ печати это допустить печать функции аргументов напрямую в другую функцию.
Сигнатура `Printf` используется для типов `...interface{}`, что допускает произвольное число аргументов, которые добавляются после формата *format*.

```go
func Printf(format string, v ...interface{}) (n int, err error) {
```

**TODO**
Within the function `Printf`, `v` acts like a variable of type `[]interface{}` but if it is passed to another variadic function, it acts like a regular list of arguments.
Here is the implementation of the function `log.Println` we used above. It passes  its arguments directly to `fmt.Sprintln` for the actual formatting.
**-**

```go
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
```

Запись `...` после `v` при вызове функции `Sprintln` объявляет компилятору о том что `v` является списком аргументов; с другой стороны `v` воспринимается как простой срез аргументов.

Если Вам необходимо большее количество информации, то смотрите документацию `godoc` в пакете `fmt`.

Кстати параметр `...` может иметь тип, для примера`...int` для функции определения минимума используется список целых чисел:

```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _ , i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```

### Присоединение(Append)

В настоящий момент? пришел момент для разъяснения конструкции встроенной функции `append`. Сигнатура функции `append` отличается от ранее описанной функции `Append`.
Схематично, выглядит следующим образом:

```go
func append(slice []*T*, elements ...*T*) []*T*
```

где *T* любой тип. Вы не можете написать в языке Go функцию в которой `T` определена вызывающим. Поэтому необходима поддержка компилятора для функции `append`.

Данная функция `append` добавляет элемент в конец среза и возвращает результат.
Причина возврата результата, в том что как и в рукописной функции `Append` массив может измениться.
Простой пример:

```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

печатает `[1 2 3 4 5 6]`.  Итак, `append` работает в принципе как `Printf` с произвольным количеством аргументов.


Но что если необходимо добавить срез в срез, как в нашей реализации `Append`? Все просто: используем `...` который мы использовали в `Output`. Вот пример кода для получение того же результата.

```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

Обращаю внимание, что без `...` компилятор напишет ошибку, так как `y` не имеет тип `int`.
