## Java IO

> Данный материал основан на главе из книги [EJC](https://github.com/vastap/EJC) с разрешения авторов. Подписывайтесь и ставьте звездочки!

### Вступление

Java IO - это API для работы с потоками данных, чтение и запись.
Представляет из себя блокирующий (синхронный) ввод/вывод. Поэтому, позже как альтернатива, появилось Java NIO (где N - non-blocking).
О их различиях подробнее можно прочитать здесь: "[Основные отличия Java IO и Java NIO](https://habrahabr.ru/post/235585/)"

### Stream - поток данных

В Java IO есть 2 потока данных: для чтения (InputStream) и для записи (OutputStream). Название указывает на направление: входяящий поток - Input, исходящий - Output. Является closeable, т.е. требует закрытия ресурса после использования:

```java
public abstract class InputStream implements Closeable {
```

InputStream является абстрактным и имеет набор реализаций, более подробно описывающих сущность данных.

![](https://user-images.githubusercontent.com/4215285/72475721-8cb24100-37fc-11ea-85e0-a38dfe7c5df6.png)

Например, FileInputStream описывает поток байт из файла, ByteArrayInputStream описывает поток байт из массива, ObjectInputStream описывает поток байт из объекта (сериализация), BufferedInputStream описывает буферизируемый поток и т.д.

Стоит заметить, что лучше использовать буферизацию потоков:
[Buffered Streams](https://docs.oracle.com/javase/tutorial/essential/io/buffers.html). Причина в том, что каждый запрос на чтение / запись обрабатывается непосредственно силами операционной системы. Поэтому каждый запрос чтения / записи приводит к обращению к диску или сетевой активности, что может быть довольно дорого. Поэтому буферизация уменьшает количество таких обращений, используя промежуточное хранилище - буфер.

### Character Streams

Помимо работы с потоками байт есть возможно работать с символьными потоками.

Такие поток управляются потомками классов Reader and Writer:

![](https://user-images.githubusercontent.com/4215285/72475746-99369980-37fc-11ea-88df-f55fa5191603.png)

### Освобождение ресурсов

Как ранее было сказано, необходимо не забывать освобождать ресурсы.
Т.к. закрываемые ресурсы реализуют java.io.Closeable (Close + able, т.е. те ресурсы, которые можно закрыть). Этот интерфес предписывает реализовывать метод `close()`.

Интересно, что такой метод выбрасывает исключение `IOException`, поэтому всех мучили страшные конструкции try-catch вокруг close, пока в Java7 интерфейс Closeable не сделали наследником от `AutoCloseable`. Данный интерфейс позволяет использовать такие ресурсы в блоке try-with-resources, что позволяет не писать close, т.к. он будет выполнен автоматически после заверешния блока try-with-resources.

Дополнительную информацию можно найти тут: [Java Core October: Exceptions. Лекция #6](https://www.youtube.com/watch?v=2_ThvTc3X8Y&feature=youtu.be&list=PLwcDaxeEINaemIX9OqrAjilBL6MTNikh8&t=2181)
В видео можно увидеть интересные подробности. Например, про то, что закрытие ресурсов выполняется в блоке, похожем на finally, который выполняется до основного finally.

### Дополнительные материалы

- Подробный цикл статей: "[Posts in Category: java io](http://lozenko.blog/category/java-io/page/4/)".
- Пример вопросов про java.io: "[Потоки ввода/вывода (вопросы и ответы)](http://javastudy.ru/interview/input-output/)".
