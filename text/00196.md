## Функции и методы (Functions, Methods)

### Множественное возвращение результатов

Одно из особенностей языка Go - это то, что функции и методы могут возвращать множество значений.

При использовании языка С, передача ошибки производится через отрицательное значение с описанием причины ошибки в "другом" месте.

При использовании языка Go, функция `Write` может вернуть одновременно **и** возвращаемое значение **и** ошибку.
Сигнатура метода `Write` в файлах пакета `os`:

```go
func (file *File) Write(b []byte) (n int, err error)
```

и как предусмотрено документацией, он возвращает число записанных байт и ненулевое значение ошибки `error`, когда `n` `!=` `len(b)`.
Это общий стиль, смотрите также раздел посвящённый ошибкам в качестве примера.

Данный подход исключает необходимость в возращении значимого параметра.
Это очень простой способ возвращения из функции количества байт среза, возвращая число и следующий параметр.

```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

Вы можете сканировать число чисел во входном срезе `b` следующим образом:


```go
    for i := 0; i < len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
```

### Именование параметров результата

Возвращаемым "параметрам" в языке Go можно давать имена и это часто используется как входные параметры.
Когда они именованы, то они инициализируются нулевым значением необходимого типа в самом начале функции.
Если функция, в которой определены именованные параметры, вызывает конструкцию возврата без аргументов, то значения именованных параметров будут использованы ей как возвращаемые значения.
Именование не обязательное, но оно может сделать код короче и чище - самодокументированным.
Если имя результата будет `nextInt`, то очевидно что тип результата `int`.


```go
func nextInt(b []byte, pos int) (value, nextPos int) {
```

На примере `io.ReadFull`:


```go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### Отсроченный вызов (Defer)

В языке Go есть оператор `defer` для управления отложенного вызова функции, который будет вызван, как только функция имеющая `defer` оканчивается.
Это не типичный но эффективный способ, когда необходимо закрыть ресурс после окончания функции.
Канонические примеры - работа с mutex или закрытие файла.

```go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

Отложенный вызов функции `Close` имеет 2 преимущества. Во-первых, гарантирует что не будет забыто закрытие файла - ошибка,  которую легко сделать, если в последствии в функции будет изменен параметр на другую папку. Во-вторых, закрытие близко расположено к открытию, что более ясно, чем располагать его в конце функции.

Аргументы отложенной функции выполняются когда выполняется `defer`, а не когда функция вызвана.
Кроме того , во избежания беспокойства по поводу изменяющихся переменных в функции, одна отложенная функция может отложить вызов множества функций.

Вот простой пример:

```go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
```

Откладывание функции в LIFO очередь, приведет к следующей работе функции при печати на экран `4 3 2 1 0` . Более интересный пример - простое отслеживание функции в программе. Мы могли бы написать простое отслеживание, как это:


```go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
```

Мы могли бы сделать лучше - используя факт отложенных функций для оценки когда будет запущен `defer`. Отслеживаемая функция может настроить аргументы неотслеживаемой функции.
К примеру:

```go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
```


выводит:


```
entering: b
in b
entering: a
in a
leaving: a
leaving: b
```

Для программистов привыкших к блочному управлению ресурсами в других языках, функция `defer` может показаться странной, но интересной и мощной, так как позволяет уйти от блочного управления к управлению в функции. В разделах `panic` и `recover` будут также рассматриваться несколько примеров.
