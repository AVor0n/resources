## Интерфейсы и другие типы

### Интерфейсы

Интерфейсы в Go позволяют создать особое поведения для объектов: *Если нечто может делать* **это** *, то это можно использовать* **здесь**. Мы уже это встречали в простых примерах, когда реализовывали функцию `String` для печати, в то время как `Fprintf` может выдавать на печать другое с методом `Write`.
Интерфейсы с одним или двумя функциями свойственны в языке Go, как `io.Writer` реализующий `Write`.

Любой тип может реализовывать множество интерфейсов.
К примеру, коллекции могут быть отсортированы с помощью функций из пакета `sort`, если она реализует `sort.Interface`, который состоит из `Len()`, `Less(i, j int) bool`, и `Swap(i, j int)` и это может задать собственный формат.
Рассмотрим пример `Sequence`

```go
//{{code "/doc/progs/eff_sequence.go" `/^type/` "$"}}
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"sort"
)

func main() {
	seq := Sequence{6, 2, -1, 44, 16}
	sort.Sort(seq)
	fmt.Println(seq)
}

type Sequence []int

// Methods required by sort.Interface.
func (s Sequence) Len() int {
	return len(s)
}
func (s Sequence) Less(i, j int) bool {
	return s[i] < s[j]
}
func (s Sequence) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

// Method for printing - sorts the elements before printing.
func (s Sequence) String() string {
	sort.Sort(s)
	str := "["
	for i, elem := range s {
		if i > 0 {
			str += " "
		}
		str += fmt.Sprint(elem)
	}
	return str + "]"
}
```

### Преобразование (Conversions)

Функция `String` работает с `Sequence` и `Sprint` уже работает со срезами. Мы может распространить данный эффект, если конвертируем  `Sequence` на  `[]int` до вызова `Sprint`.

```go
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
```

Это функция другой пример техники конвертирования для вызова `Sprintf` безопасно для функции `String`.
Так как два типа (`Sequence` и `[]int`) одинаковы, то мы можем игнорировать имя типа, это допустимое конвертирование между ними.
При конвертации не происходит создание нового значения, это временная замена существующего значения на новый тип.
(При других допустимых конвертациях, к примеру из целого числа в число с плавающей точкой, происходит создание нового значения.)


Это идиоматично в программе Go - конвертация типа позволяет получить доступ к другим функциям. К примеру, мы можем использовать существующий тип `sort.IntSlice`:

```go
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
```

Теперь, наш `Sequence` реализует множество интерфейсов (сортировка и печать),  мы можем использовать множество типов (`Sequence`, `sort.IntSlice` и `[]int`), которые выполняют определенную часть работ.
Это не типично в использовании, но эффективно.

### Конвертация интерфейсов и привязка типов

Переключатель типов(Type switches) является одной из форм конвертации: на основе интерфейса и переключателя для каждого элемента, в некотором смысле преобразует тип в элемент переключателя.
Это простой вариант как в коде `fmt.Printf` конвертирует значение в строку, используя переключатель типа.
И если это уже строка, мы хотим чтобы фактическое значение происходило по его интерфейсу, но в случаи если она имеет функцию `String`, то хотим чтобы в результате вызывалась именно она.

```go
type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```

В первом случае ищется конкретное значение, во втором случаи происходит преобразование интерфейса в другой интерфейс.
Это хороший подход в преобразовании типов.

Что если, мы будем беспокоиться лишь об одном типе? Если мы знаем что значение имеет тип `string` и мы хотим вытащить только его?
Можно сделать переключатель только с одним типом, но это будет *type assertion*.
И *type assertion* берет значение интерфейса и переводит из его значения в его тип.
Заимствование типа из открытия *type switch*, но переводит тип с помощью ключевого слова `type`:

```go
value.(typeName)
```

и в результате у нас значение со статическим типом `typeName`.
Этот тип должен быть конкретным типом имеющим интерфейс, или второй тип интерфейса - это тип в который может быть конвертирован.
Если мы знаем что это строка в значении, то мы можем записать:


```go
str := value.(string)
```

Но если выясниться, что значение хранит не строку, то программа будет обрушена во время работы в *run-time error*.
Для защиты от этого используется идиома *запятая, ок* *"comma, ok"* для безопасности и проверка является ли значение строкой:


```go
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

В случаи неудачи, `str` будет всё ещё существовать и будет типом строка, но будет иметь нулевое значение - пустую строку.


Для иллюстрации, используем условие `if`-`else` как эквивалент переключателя типов *type switch* в начале этого раздела.

```go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```

### Общее (Generality)

Если тип существует только для реализации интерфейса и никогда не будет экспортироваться за пределы интерфейса, то нет необходимости экспортировать сам тип.
Экспортирование только интерфейса делает более понятным, что значение имеет не так интересно как поведение интерфейса.
Также это позволяет избегать повторения документации для каждого экземпляра общего метода.


В таких случаях, конструктор может возвращать значение интерфейса, что лучше чем реализованный тип.
Для примера, в  библиотеках хэш *hash* оба конструктора `crc32.NewIEEE` и `adler32.New` возвращают тип интерфейса `hash.Hash32`.
Для подстановки алгоритма CRC-32 для Adler-32 в программе Go требуется только изменить вызов конструктора, а остальная часть кода не зависит от алгоритма.


Подобный подход позволяет создать поток шифровальных алгоритмов помимо имеющихся в пакете `crypto`, устанавливаются в цепочку отдельно от блока шифрования.
Интерфейс `Block` в пакете `crypto/cipher` имеющий поведение -  шифрование, который обеспечивает шифрование одного блока данных.
Это по аналогии с пакетом `bufio`, пакет шифрования реализует этот интерфейс и может использовать конструктор потока шифрования, представляя интерфейс `Stream` без известных деталей о шифровании.

Интерфейсы `crypto/cipher` выглядят следующим образом:

```go
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
```

Определение режима счётчика потока *counter mode (CTR) stream*, который превращает блоки шифрования в поток шифрования, обратите внимание, что шифрование блоков абстрагировано:

```go
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
```

Принятое `NewCTR` не только для одного конкретного алгоритма шифрования и исходных данных, но для любой реализации интерфейса `Block` и любой `Stream`.
Так как он возвращает тип интерфейса, замена шифрование CTR с другими режимами шифрования это локальное изменение. Вызов конструктора должен быть отредактирован, и при этом окружающий код не заметит разницы , так как в результате `Stream`.

### Интерфейсы и методы (функции)

Так как метод может иметь почти всё, поэтому все можно удовлетворить интерфейсами.
Один из примеров из пакета `http`, который имеет интерфейс `Handler`. Любой объект реализующий `Handler` может служить для HTTP запросов.

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Сам интерфейс `ResponseWriter` обеспечивает функции для возврата ответа клиенту.
Эти функции включают метод `Write`, то `http.ResponseWriter` можно  использовать везде как где можно использовать `io.Writer`. `Request(Запрос)` это структура хранящая информацию о запросе от клиента.

Для упрощения, давайте игнорировать POSTs и предположим что HTTP запросы всегда используют GETs; Это упрощение не влияет на способ настройки обработчика *handlers*.
К примеру следующий код показывает полный обработчик для подсчета количества раз показа данной страницы.

```go
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

(Обратите внимание, на то как `Fprintf` печатает в `http.ResponseWriter`.)
Для справки, следующий код показывает как присоединить сервер к узлу в *URL tree*.

```go
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
```

Но зачем использовать структуру для `Counter`? Все что нам необходимо - это целое число.
(Для получателя *receiver* необходим указатель, тогда инкремент будет виден для вызывающего)

```go
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
```

Что делать если Ваша программа имеет некое внутреннее состояние и необходимо уведомить что страница была посещена? Необходимо связать веб страницы каналом.

```go
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
```

Если нам требуется представить на `/args` аргументы использованные для запуска приложения сервера.
Просто необходимо написать функцию для печати аргументов.

```go
func ArgServer() {
    fmt.Println(os.Args)
}
```

Как превратить это в HTTP сервер?  Мы могли бы сделать метод `ArgServer` некоторого типа значение которого мы игнорируем, но есть более простой путь.
Так как мы можем определить метод для любого типа, кроме указателя и интерфейса, то мы можем записать метод для функции.
В пакете `http` есть следующий код:

```go
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
```

Это тип `HandlerFunc` с методом `ServeHTTP`, поэтому значения данного типа может служит для запросов HTTP. Посмотрим на реализацию метода: *receiver* это функция, `f`, и метод называется `f`. Это может показаться странным, но это ничем не отличается от работы с каналами и метод бы отсылал на канал.

Для создания `ArgServer` как HTTP сервера, вначале мы изменим корректную сигнатуру.

```go
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
```

Сейчас, `ArgServer` имеет ту же сигнатуру как `HandlerFunc`, поэтому его можно конвертировать в этот тип для доступа к его методам, просто как сконвертировать `Sequence` в `IntSlice` для доступа к `IntSlice.Sort`.
Код для настройки лаконичен:

```go
http.Handle("/args", http.HandlerFunc(ArgServer))
```

Когда кто-то посещает страницу `/args`, обработчик **handler** устанавливает страницу со значением `ArgServer` и типом `HandlerFunc`.
Сервер HTTP будет вызывать метод `ServeHTTP` данного типа с получателем `ArgServer`, который будет вызывать `ArgServer` через вызов `f(c, req)` внутри `HandlerFunc.ServeHTTP`.
Вследствие этого аргументы будут отображены.

В этом разделе мы сделали сервер HTTP из структуры, целого числа, канала, и функции, все потому что интерфейсы имеют только набор методов, которые могут быть определены для (почти) любого типа.
