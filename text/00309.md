## Регулярные выражения

[Регулярное выражение](https://tproger.ru/articles/regexp-for-beginners/) - это последовательность символов, которая помогает сопоставлять или находить другие строки или наборы строк, используя специальный синтаксис, содержащийся в шаблоне. В Java есть поддержка использования регулярных выражений через пакет `java.util.regex`. В этом разделе рассказывается о том, как использовать регулярные выражения в Java. Попробуем разобраться в них.

Для начала прочитайте что такое регулярные выражения [тут](https://tproger.ru/articles/regexp-for-beginners/).

### Синтаксис

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

...

Pattern patternName = Pattern.compile(regex);
Matcher matcherName = patternName.matcher(textToSearch);
matcherName.matches() // Вернет true, если textToSearch соответствует регулярному выражению
matcherName.find() // Выполняет поиск в textToSearch первого экземпляра подстроки, соответствующей регулярному выражению. Последующие вызовы будут работать с остатком строки.

...

```

> В Java `\` экранируется `\\`, поэтому `\` в строке регулярного выражения должна вводиться как `\\`. Если вам нужно избежать `\\` (чтобы сопоставить `\` с регулярным выражением, вам нужно ввести ее как четырехкратную обратную косую черту - `\\\\`.

### Символы

| Символ | Описание |
|---|---|
| `*` |  Предшествующее выражение может встречаться ноль или более раз |
| `+` | Предшествующее выражение может встречаться один или более раз  |
| `?` | Предшествующее выражение может встречаться ноль или один раз  |

Со всем списком вы можете ознакомится [тут](https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/regular-expression-language-quick-reference). В первую очередь обратите внимание на `.`, `*`, `^`, `{}`, `[]`.

### Экранирование

Чтобы использовать определенные символы регулярных выражений (`?+|` и т. д.) в буквальном значении, их необходимо экранировать. В обычном регулярном выражении это делается обратной косой чертой `\`. Однако, поскольку он имеет особое значение в строках Java, вы должны использовать двойную обратную косую черту `\\`.

Эти два примера не будут работать:

```java
"???".replaceAll ("?", "!"); // java.util.regex.PatternSyntaxException
"???".replaceAll ("\?", "!"); // Неверное экранирование
```

Этот пример будет работать:

```java
"???".replaceAll ("\\?", "!"); //"!!!"
```

#### Разделение строки

Этот код не возвращает ожидаемый результат:

```java
"a|b".split ("|"); // [a, |, b]
```

Это возвращает ожидаемый результат:

```java
"a|b".split ("\\|"); // [a, b]
```

Экранирование обратной косой черты `\`:

Получим ошибку:

```java
"\\".matches("\\"); // PatternSyntaxException
"\\".matches("\\\"); // Syntax Error
```

Все ок:

```
"\\".matches("\\\\"); // true
```


### Обратная косая черта

Как мы уже говорили, если вы хотите использовать обратную косую черту в своем регулярном выражении, вам придется ее экранировать.

Обратная косая черта является escape-символом (символом экранирования) в регулярных выражениях. Вы можете использовать `\\` для добавления обратной косой черты в регулярное выражение.

Но в Java обратная косая черта также является escape-символом в строках. Чтобы сделать регулярное выражение из строкового литерала, вы должны экранировать каждый его обратный слеш.

Например, рассмотрим соответствующие строки, такие как "C:\dir\myfile.txt" и регулярное выражение `(([A-Za-z]):\\(.*)`.

Чтобы написать этот шаблон в Java, каждый обратный слеш в регулярном выражении должен быть экранирован.

```java
String path = "C:\\dir\\myfile.txt";
System.out.println("Локальный путь: " + path); // "C:\dir\myfile.txt"

String regex = "([A-Za-z]):\\\\.*"; // Четыре соответствуют одному
System.out.println("Regex:      " + regex); // "([A-Za-z]):\\(.*)"

Pattern pattern = Pattern.compile(regex);
Matcher matcher = pattern.matcher(path);
if ( matcher.matches()) {
    System.out.println("Этот путь включает диск " + matcher.group(1) + ":.");
    // Данный путь включает диск C:.
}
```

Если вы хотите сопоставить _две_ обратные косые черты, вам придется использовать _восемь_ в java-строке. `\\` => регулярные выражения `\\\\` => java с ее строковыми литералами `\\\\\\\\`. О боги!

```java
String path = "\\\\myhost\\share\\myfile.txt";
System.out.println("UNC путь: " + path); // \\ myhost\share\myfile.txt"

String regex = "\\\\\\\\(.+?)\\\\(.*)"; // Восемь соответствует двум
System.out.println("Regex:    " + regex); // \\\\(.+?)\\(.*)

Pattern pattern = Pattern.compile(regex);
Matcher matcher = pattern.matcher(path);

if ( matcher.matches()) {
    System.out.println( "Этот путь соответствует хосту '" + matcher.group( 1 ) + "'.");
    // Этот путь соответствует хосту 'myhost'.
}
```

### Литералы regex

Если вам нужно сопоставить символы, которые являются частью синтаксиса регулярного выражения, вы можете пометить весь шаблон или его часть как литерал регулярного выражения.

`\Q` отмечает начало литерала регулярного выражения. `\E` обозначает конец литерала регулярного выражения.

```java
// тут мы получим исключение PatternSyntaxException так как не закрыта квадратная скобка. :(
"[123".matches("[123");

// но, если мы все обернем в \Q and \E, мы сможем использовать шаблон, как планировали.
"[123".matches("\\Q[\\E123"); // получим true
```

Более простой способ сделать это без необходимости запоминать escape-последовательности `\Q` и `\E` - использовать `Pattern.quote()`.

### Negative Lookahead

Чтобы сопоставить что-то, что не должно содержать данную строку, можно использовать отрицательный опережающие проверки.

Синтаксис: `(?!string-to-not-match)`.

```java
// не соответствует "попкорн"
String regexString = "^(?!попкорн).*$";
System.out.println("[попкорн] " + ("попкорн".matches(regexString) ? "соответствует!" : "нет!"));
System.out.println("[уникорн] " + ("уникорн".matches(regexString) ? "соответствует!" : "нет!"));
```

Результат:

```bash
[popcorn] nope!
[unicorn] matched!
```

### Группы захвата

Если вам нужно извлечь часть строки из входной строки, мы можем использовать ***группы захвата*** регулярных выражений.

В этом примере мы начнем с простого регулярного выражения для номера телефона:

```regexp
\d{3}-\d{3}-\d{4}
```

Если в регулярное выражение добавлены скобки, каждый набор скобок считается _группой захвата_. В этом случае мы используем так называемые нумерованные группы захвата:

```
(\d{3})-(\d{3})-(\d{4})
^-----^ ^-----^ ^-----^
Group 1 Group 2 Group 3
```

Прежде чем мы сможем использовать их в Java, мы не должны забывать следовать обратной косой черте, что приводит к следующему шаблону:

```regexp
"(\\d{3})-(\\d{3})-(\\d{4})"
```

Сначала нам нужно скомпилировать шаблон регулярного выражения, чтобы создать `Pattern`, а затем нам нужен `Matcher` для сопоставления нашей входной строки с шаблоном:

```java
Pattern phonePattern = Pattern.compile("(\\d{3})-(\\d{3})-(\\d{4})");
Matcher phoneMatcher = phonePattern.matcher("abcd800-555-1234wxyz");
```

Затем `Matcher` должен найти первую подпоследовательность, которая соответствует регулярному выражению:

```java
phoneMatcher.find();
```

Теперь, используя `group` метод, мы можем извлечь данные из строки:

```java
String number = phoneMatcher.group(0); // "800-555-1234" (Группа 0 - все, что соответствует регулярке)
String aCode = phoneMatcher.group(1); // "800"
String threeDigit = phoneMatcher.group(2); // "555"
String fourDigit = phoneMatcher.group(3); // "1234"
```

> `Matcher.group()` может использоваться вместо `Matcher.group(0)`.

В Java 7 были представлены именованные группы захвата. Именованные группы захвата функционируют так же, как нумерованные группы захвата (но с именем вместо числа), хотя в синтаксисе есть небольшие изменения. Использование именованных групп захвата улучшает читабельность.

Мы можем изменить приведенный выше код для использования именованных групп:

```regexp
(?<AreaCode>\d{3})-(\d{3})-(\d{4})
^----------------^ ^-----^ ^-----^
AreaCode           Group 2 Group 3
```

Чтобы получить содержимое "AreaCode", мы можем вместо этого использовать:

```java
String aCode = phoneMatcher.group("AreaCode"); // "800"
```

Ура! Вот и все. Вы можете посмотреть [это крутое видео по регуляркам](https://www.youtube.com/watch?v=OBkDT25X_S8), чтобы закрепить материал.

<p class="source">Данный текст является переводом оригинальной документации Stack Overflow, созданной <a href="https://riptutorial.com/contributor?exampleId=530">следующими участниками</a> и выпущенной под <a href="https://stackoverflow.com/users/865910/ordiel">CC BY-SA 3.0</a>.</p>