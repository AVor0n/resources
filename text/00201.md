## Пустой идентификатор (The blank identifier **_**)

Мы уже упоминали пустой идентификатор пару раз, в разделах о циклах `for` `range` и картах `maps`.
Пустой идентификатор может быть назначен или объявлен для любого типа, значение при этом отбрасывается.
Это чем то похоже на запись в Unix файл в `/dev/null`: Это значение только на запись, где переменная необходима, но значение не важно.
Есть дополнительные способы использования.

### Пустой идентификатор в множественном присваивании (**_**)

Использование пустого идентификатора в цикле `for` `range` является лишь одним случаем применения в общей картине множественного присваивания.


Если требуется множество значений на левой стороне при присваивании, но одно из значений не будет использоваться программой, то используется пустой идентификатор на левой стороне присвоения для того чтобы избежать необходимости в ненужных переменных и создании понимания что значение отброшенное.
Например, когда вызывается функция возвращающая значение и ошибку, но при этом только ошибка важна, то пустой идентификатор используется для того чтобы отбросить ненужное значение.

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

Иногда Вы увидите код в котором отбрасывается ошибка, это ужасная практика. Всегда проверяйте возвращенную ошибку, так как они предоставляются по некой причине.


```go
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

### Неиспользуемое импортирование и значения

Ошибкой является неиспользование пакета или объявление переменной без использования.
Неиспользованный импорт увеличивает программу и делает компиляцию медленнее, в то время как переменная инициализированная но не используется, по крайней мере приводит к пустому вычислению или может является индикатором об ошибке.
Однако неиспользуемые импорты и переменные возникают, когда программа на стадии активной разработки и удаление их может раздражать, только лишь для того чтобы прошла компиляция и если они снова понадобятся позже.
Пустые идентификаторы позволяют создать обход(**workaround**).

Это полунаписанная программа имеет два неиспользуемых импорта (`fmt` и `io`) и не используемую переменную (`fd`), и она не проходит компиляцию, но было бы хорошо если бы можно было увидеть, что код корректен.

```go
///{{code "/doc/progs/eff_unused1.go" `/package/` `$`}}
package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	fd, err := os.Open("test.go")
	if err != nil {
		log.Fatal(err)
	}
	// TODO: use fd.
}
```

Для того чтобы избежать жалоб о неиспользуемых импортах, необходимо использовать символ пустого идентификатора для обозначения импортирования пакета.
Аналогично, можно поступать с неиспользуемой переменной `fd` при использовании пустого идентификатора, что приведёт к избеганию ошибки о неиспользованной переменной.
Следующая версия программы будет компилироваться.

```go
//{{code "/doc/progs/eff_unused2.go" `/package/` `$`}}
package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
	fd, err := os.Open("test.go")
	if err != nil {
		log.Fatal(err)
	}
	// TODO: use fd.
	_ = fd
}
```

В соответствии с соглашением, глобальное объявление для замалчивания ошибки импорта должно идти сразу за импортированием и должно быть откомментировано, это сделано для того чтобы легко можно было найти и помнить об отчистки позже.

### Импортирование для побочного эффекта (Import for side effect)

Неиспользуемые импорты, как например `fmt` и `io` в предыдущем примере, в конечном счете должны быть удалены: пустое задание должно определять что код в процессе разработки.
Но иногда, используется импортирование пакета только для создания побочного влияния, без какого либо явного использования.
К примеру, для функции `init` в пакете [net/http/pprof](https://golang.org/pkg/net/http/pprof/) регистрирует HTTP обработчики для обеспечения отладочной информацией.
Он имеет экспортированный API, но большинству клиентов необходима только регистрация обработчиков и получение доступа к данным через веб-страницу.
Только для импортирования пакета с этим побочным эффектом, переименовывают пакет в пустой идентификатор:

```go
import _ "net/http/pprof"
```

Эта форма импортирования означает, что данный пакет импортируется для данного побочного эффекта, потому что нет другой возможности использовать пакет: в этот файл, не имеет имени. (Если же он имеет и мы не используем это имя, то компилятор отменит программу.)

### Проверка интерфейса (Interface checks)

Как мы видели ранее в разделе об интерфейсах, нет необходимости в объявлении что тип реализует определенный интерфейс.
Вместо этого, тип реализует интерфейс только путем реализации методов интерфейса.
На практике, большинство преобразований интерфейсов статично и поэтому проверяется во время компиляции.


К примеру, передавая `*os.File` в функцию ожидающая `io.Reader` не будет скомпилировано, так как `*os.File` не реализует интерфейс `io.Reader`.


Хотя все же некоторые проверки интерфейсов происходят во время выполнения.
Один из примеров в пакете [encoding/json](https://golang.org/pkg/encoding/json/), который определяет интерфейс [Marshaler](https://golang.org/pkg/encoding/json/#Marshaler). Когда **JSON encoder** принимает значение, которое реализует этот интерфейс, *encoder* вызывает функцию упаковщик значений для преобразования в JSON, в отличии от стандартного преобразования.

*Encoder* проверяет эти свойства во время работы:

```go
m, ok := val.(json.Marshaler)
```

Если необходимо только запросить тип реализуемого интерфейса без использования самого интерфейса, то это часть проверки ошибок, используйте пустой идентификатор для игнорирования защиты типов:

```go
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

Одна из ситуаций применения это когда необходимо гарантировать в рамках пакета что данный тип реализует интерфейс.
Если взглянуть на пример [json.RawMessage](https://golang.org/pkg/encoding/json/#RawMessage), где необходима пользовательское представление в формате JSON, он должен реализовывать `json.Marshaler`, но отсутствует статическое преобразование для автоматической проверки компилятором.
Если определенный тип не будет реализовывать интерфейс, то *JSON encoder* будет все же работать, но без пользовательской реализации.
Для гарантирования корректной реализации, в пакете можете использовать пустой идентификатор для глобальной декларации:

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

в этой деклорации, присвоение с конвертацией `*RawMessage` к `Marshaler` требует чтобы, `*RawMessage` реализовывал `Marshaler` и данная проверка будет производиться во время компиляции.
В случаи если интерфейс `json.Marshaler`, этот пакет не будет компилироваться и мы будем знать об обновлении.

Использование пустого идентификатора в данном случае является индикатором о проверки типов, и при этом не создается переменной.
Не используйте этот подход для проверки каждого типа.
В соответствии с соглашением, такое объявление используется только когда отсутствует статическая конвертация уже существующая в коде, и является редким событием.
