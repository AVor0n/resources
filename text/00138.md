## Принципы ООП

### Вступление

К этому моменту вы изучиле и сможете на практике использовать наиболее распространенные шаблоны создания и организации объектов в JavaScript. Но это всего лишь вершина айсберга. Более важным, чем изучение синтаксиса Фабричных Функций или Модулей, является выяснение того, как эффективно их использовать.

Вся эта серия уроков была посвящена парадигме "Объектно-ориентированное программирование" (ООП). Основы создания объектов и классов относительно просты. Но гораздо сложнее понять, что поместить в каждый объект, когда создавать новый объект, когда позволить объекту "наследоваться" от другого.

К счастью, есть несколько концепций и принципов, которые могут нам. Этот урок представляет собой введение в наиболее важные из этих концепций. Имейте в виду, что обычно нет четкого ответа на ваши вопросы по дизайну приложения. Некоторые шаблоны, модели и идеи, очевидно, лучше, чем другие, но часто приходится искать компромисс при принятии решения о том, что использовать. Другими словами... эти принципы не являются обязательными правилами - это лишь полезные рекомендации.

Так как вы читаете данный урок, вы может вернуться к некоторым уже выполненным проектам и подумать о том, как уже написанное вами соответствует приведенным принципам. И, конечно же, когда вы будете двигаться дальше, помните о них при создании новых проектов.

### Принцип единственной ответственности

Одна из самых важных вещей, которую нужно помнить при создании своих объектов, - это __Принцип единственной ответственности__, который гласит, что класс (или объект или модуль... ну вы поняли) должен иметь только _одну_ ответственность. Рассмотрим распространенный пример. Большая часть нашего кода имеет дополнительные функции для обновления и записи в DOM. И действительно хорошая идея - это отделить ваши функции связанные с DOM от основной логики приложения.

Итак, вместо этого:

~~~javascript
function isGameOver() {

  // логика игры тута!

  if (gameOver){
    const gameOverDiv = document.createElement('div')
    gameOverDiv.classList.add('game-over')
    gameOverDiv.textContent = `${this.winner} выиграл игру!`
    document.body.appendChild(gameOverDiv)
  }
}
~~~

Вы должны вынести всю логику манипулирующую с DOM в отдельный модуль и использовать его так:

~~~javascript
function isGameOver() {

  // логика игры тута!

  if (gameOver){
    DOMStuff.gameOver(this.winner)
  }
}
~~~

На самом деле - функция `isGameOver` не должна вызывать функцию DOM, так как эта логика должна быть в другом месте (непосредственно в игровом цикле).

> Принцип единственной ответственности - это первый из широко распространенного набора 5 принципов проектирования, называемых принципами __SOLID__. В следующих статьях упоминается эта аббревиатура. Принцип единственной ответственности, безусловно, самый актуальный из 5. Не стесняйтесь копаться в остальных принципах SOLID, если хотите... но обратите особое внимание на принцип единственной ответственности.

1. <span class="btn-fill btn btn-xs btn-success">eng</span> Прочитайте [эту статью](http://aspiringcraftsman.com/2011/12/08/solid-javascript-single-responsibility-principle/);
2. <span class="btn-fill btn btn-xs btn-success">eng</span> [Эта статья](https://thefullstack.xyz/solid-javascript/) затрагивает ту же тему, а также кратко охватывает остальную часть __SOLID__;
3. <span class="btn-fill btn btn-xs btn-success">eng</span> [Еще одна](https://medium.com/@cramirez92/s-o-l-i-d-the-first-5-priciples-of-object-oriented-design-with-javascript-790f6ac9b9fa) для закрепления;
4. [SOLID принципы в JavaScript](https://getinstance.info/articles/good-code-principles/solid-single-responsibility-javascript/). На сайты представлена информация о каждом принципе;
5. [Краткое описание каждого принципа](http://blog.osinpaul.ru/2017/12/24/solid-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%B2-js-%D1%87%D0%B5%D1%80%D0%BD%D0%BE%D0%B2%D0%B8%D0%BA/).


### Слабосвязанные объекты

Очевидно, что все наши объекты предназначены для совместной работы, что и формирует наше конечное приложение. Однако вы должны позаботиться о том, чтобы ваши отдельные объекты могли как можно дольше оставаться в одиночестве. __Сильно связанные___ объекты - это объекты, которые настолько сильно зависят друг от друга, что удаление или замена одного из них будет означать, что вам придется полностью изменить другой - полнейшая печаль, беда.

Все это довольно сильно связано с принципом единственной ответственности, но с другого угла. Например, если мы пишем игру и хотели бы полностью изменить интерфейс в будущем без полной переработки логики игры, то нам необходимо написать сначало ядро нашей игры, затем сам интерфейс (например с помощью `console.log`) максимально не связывая его с ядром. По итогу, когда мы захотим изменить интерфейс на отрисовку в DOM, нам не нужно будет перерабатывать всю логику игры, а лишь точки соприкоснавения основной логики игры (ядра) с логикой интерфейса.

1. <span class="btn-fill btn btn-xs btn-success">eng</span> [Эта статья](https://www.innoarchitech.com/scalable-maintainable-javascript-coupling/) все объясняет.
2. Лучшая книга на эту тему, которую мы когда-либо читали, - [Ruby. Объектно-ориентированное проектирование](https://www.ozon.ru/context/detail/id/138551500/). К сожалению, она не бесплатна... и не о JavaScript. В любом случае, мы рекомендуем ее. Если вы не знаете Ruby, это достаточно простой язык, который вам не нужно изучать, чтобы следовать примерам из книги. Она невероятна.
