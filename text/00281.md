## Enum

### Введение

Существует ряд задач, в которых требуется некоторый тип данных ограничить множеством допустимых значений.

Это могут быть дни недели(понедельник, вторник и т.д), времена года(весна, зима, лето, осень), типы животных(членистоногие, моллюски, иглокожие и т.д), [HTTP status code](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP) и прочее.

Т.е перечислить допустимые значения.

Так вот, в простейшем приближении можно сказать, что перечисление - это список именованных, логически связанных констант.

### Перечисления в Java

В `Java` перечисления появились с версии `1.5+`.

Перечисления создаются с помощью ключевого слова `enum`(enumeration - перечисление), затем идет список элементов перечисления через запятую:

```java
public enum NUMBER {
    ONE,
    TWO,
    THREE,
    FOUR
}
```

Главное, что стоит помнить, это то, что `enum` - это класс. Это значит, что можно добавить конструкторы, методы, объявить переменные.

```java
public enum WeekDay {
   SUNDAY ("Воскресенье"),
   MONDAY ("Понедельник"),
   TUESDAY ("Вторник"),
   WEDNESDAY ("Среда"),
   THURSDAY ("Четверг"),
   FRIDAY ("Пятница"),
   SATURDAY ("Суббота");

   private String title;

   WeekDay(String title) {
       this.title = title;
   }

   public String getTitle() {
       return title;
   }

   @Override
   public String toString() {
       return "WeekDay{" +
               "title='" + title + '\'' +
               '}';
   }
}
```

Элементы перечисления - экземпляры `enum`-класса, доступные статически.

Enum может реализовывать сколько угодно интерфейсов, но не может участвовать в наследовании.

Это ограничение связано с тем, что `enum` **уже** неявно отнаследован от класса `java.lang.Enum`.

Благодрая чему имеет методы:

* `public final int ordinal()` - возвращает порядковый номер константы в перечислении, считая от 0.
* `public final String name()` - возвращает имя константы так, как оно было объявлено в перечислении.

```java
public class EnumExample {
    public static void main(String[] args) {
        for (Ex e : Ex.values())
            System.out.println(e.ordinal() + " has name " + e.name());
    }
}

enum Ex {
    ONE, TWO, THREE
}
```

Еще одним ограничением является то, что для `enum` нельзя указывать модификаторы `final`  и `abstract`. Что в принципе логично, так как перечисления в наследовании участвовать не должны и абстрактными быть не могут - иначе что же это за перечисления?

Также у перечисления есть возможность получить массив всех возможных значений этого перечисления в том порядке, в котором они объявлены. За это отвечает статический метод `values()`.

```java
for (Ex e : Ex.values())
    System.out.println(e);
```

Статический метод `valueOf(String name)`, вернет ссылку на константу перечисления по её имени.
Если перечисление не содержит элемента с именем name - выбрасывается `java.lang.IllegalArgumentException`:

```java
public class EnumExample {
    public static void main(String[] args) {
        System.out.println(Ex.ONE);
        System.out.println(Ex.valueOf("TWO"));
        System.out.println(Ex.valueOf("TWO_ERROR")); //exception
    }
}

enum Ex {
    ONE, TWO, THREE
}
```

---

**Вопрос**:

Можно ли перечисления сравнивать не через `equals`, а через `==`?

**Ответ**:

Можно!

Так как значения перечисления существуют в единственном экземпляре, поэтому их можно сравнивать их через `==`:

```java
Season season = Season.SUMMER;
if (season == Season.AUTUMN) season = Season.WINTER;
```

Более того, такой способ сравнения позволит избежать `java.lang.NullPointerException` и работает быстрее!

```java
private enum Shape{ RECTANGLE, SQUARE, CIRCLE, TRIANGLE; }

private enum Status{ ON, OFF; }

Shape unknown = null;
Shape circle = Shape.CIRCLE;
boolean result = unknown == circle; //return false
result = unknown.equals(circle); //throws NullPointerException
```

---

Как уже было сказано выше, у перечисления могут быть конструкторы:

```java
public enum EnumExample {
    ONE("ONE_ONE") {
        @Override
        public void method() {
            System.out.println("Method of " + this.name);
        }
    }, TWO("TWO_TWO") {
        @Override
        public void method() {
            System.out.println("Method 2 of " + this.name);
        }
    };

    private String name;

    EnumExample(String name) {
        this.name = name;
    }

    public abstract void method();
}
```

Если в перечислении нет ни одного объявления конструктора, то автоматически добавляется конструктор по умолчанию без параметров, с модификатором доступа `private`.
При этом, конструктор перечисления *НЕ* может использовать `super`!

---

**Вопрос**:

Могут ли у перечисления быть абстрактные методы? Ведь это же класс!

**Ответ**:

Могут!

У перечисления могут быть абстрактные-методы, тогда каждое элемент должен определить такой метод:

```java
public enum EnumExample {
    ONE("ONE_ONE") {
        @Override
        public void method() {
            System.out.println("Method of " + this.name);
        }
    }, TWO("TWO_TWO") {
        @Override
        public void method() {
            System.out.println("Method 2 of " + this.name);
        }
    };

    private String name;

    EnumExample(String name) {
        this.name = name;
    }

    public abstract void method();
}
```

---

Еще одним важным дополнением является то, что `enum` по умолчанию реализует интерфейс `java.lang.Comparable`, что позволяет использовать его в как `java.util.TreeSet`, так и в `java.util.TreeMap`.

---

**Вопрос**:

А могут ли быть `enum` **без** ничего? Без экземпляров, но с методами?

**Ответ**:

Могут!

Но вам потребуется добавить `;` для того, чтобы усмирить компилятор.

```java
public enum Example {
    ;
    public static boolean isValid() {
        throw new UnsupportedOperationException("Not supported yet.");
    }
}
```

---

### Заключение

Использование `enum` позволяет ограничить множество допустимых значений для некоторого типа данных.

Элементы enum - это статически доступные экземпляры enum-класса.

Грубо говоря, `enum` - это точно такой же класс, у которого может быть состояние(свойства класса), поведение(методы), конструкторы, он может реализовывать интерфейсы, но лишен права участвовать в наследовании.

При этом все экземпляры этого класса уже объявлены - перечислены.

Вы не можете создавать экземпляры `enum` вне границ `enum`, поскольку у `enum` нет `public` конструктора.

### Полезные ссылки

* [Enum in Java](http://www.quizful.net/post/java_enums)
* [Сравнение enum](https://javarevisited.blogspot.com/2013/04/how-to-compare-two-enum-in-java-equals.html)

<p class="source">Данный материал основан на главе из книги <a href="https://github.com/qcha/JBook">JBook</a> с разрешения авторов. Подписывайтесь и ставьте звездочки!</p>