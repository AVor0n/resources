## Интерфейс java.util.Map

### Введение

Как уже было сказано во введении, интерфес `java.util.Map` не имеет отношения к интерфейсу `java.util.Collection`, однако формально является коллекцией.

По сути, это коллекция `пар` ключ->значение, а `java.util.Map` это интерфейс ассоциативного массива.

В интерфейсе `java.util.Map` параметризуются два типа, это ключ и значение.

Объявление `java.util.Map` выглядит как:

```java
public interface Map<K,V> {
    // ...
}
```

Иногда реализации `java.util.Map` называют 'мапами', хэш-таблицами, в `Python` же это и вовсе `словари`.

> При этом реализации `java.util.Map` могут быть построены не на хэшах и не являться хэш-таблицами.

Название `Map` появилось как сокращение слова `mapping`, что значит `отображение`, `соответствие`.

Каждому ключу соответствует некоторое значение.

При этом стоит отметить, что не может быть повторяющихся ключей, что следует из названия и смысла `Map`: каждому ключу соответствует значение.

---

**Вопрос**:

Почему бы тогда не назвать просто `словарь`, как в `Python`?

**Ответ**:

На самом деле в `Java` существует абстрактный класс `java.util.Dictionary` еще с версии `1.0`, который сейчасс уже давно не используется.

И до этого иерархия как раз и была основана на классе `java.util.Dictionary`, например, как одна из старых реализаций хэш-таблицы - `java.util.HashTable`.

Класс `java.util.Dictionary` является полностью абтрактным, без какого-либо состояния.

Но благодаря `WORA` в `Java` просто так ничего не меняют и не удаляют, поэтому старые классы остались, а новую иерархию начали строить с интерфейсов.

Интерфейс `java.util.Map` появился в `Java` начиная с версии `1.2`.

---

Основные методы, которые предоставляет интерфейс `java.util.Map`:

* `V get(Object key)`
* `V put(K key, V value)`
* `int indexOf(Object element)`
* `V remove(Object key)`
* `Set<K> keySet()`
* `Collection<V> values()`
* `Set<Map.Entry<K, V>> entrySet()`

Это значит, что все реализации интерфейса `java.util.Map` позволяют доставать, класть и удалять элементы по ключам, а также предоставлять множество ключей и коллекцию хранимых значений.

Отдельного рассмотрения заслуживает последний метод: `Set<Map.Entry<K, V>> entrySet()`.

#### Интерфейс java.util.Map#Entry

Как уже было сказано выше, `Map` это набор пар ключ-значение.

Так вот интерфейс, описывающий поведение такой пары, называется `Entry`.

Объявление `java.util.Map#Entry` выглядит как:

```java
interface Entry<K,V>{
    // ...
}
```

И предоставляет методы, позволяющие получить/установить ключ и значение.

Помимо всего прочего предоставляются также компараторы для сравнения пар по ключу и значению.

##### Реализации java.util.Map#Entry

У каждого класса, реализующего интерфейс `java.util.Map` своя реализация `java.util.Map#Entry`, но большинство из них основано на стандартной реализации, которая объявлена у `java.util.HashMap`.

Объявление выглядит следующим образом:

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    // some code
}
```

В этой реализации нет каких-то подводных камней и сложностей, кроме того, что она объявлена с модификатором доступа `package`.

Ее использование ограничено в рамках пакета, в классе которого она объявлена, т.е `java.util`.

Стандартная реализация, доступная для использования везде, объявлена у `java.util.AbstractMap` и называется `SimpleEntry`.

Объявление выглядит следующим образом:

```java
 public static class SimpleEntry<K,V>
        implements Entry<K,V>, java.io.Serializable {

        private final K key;
        private V value;

        // some code
}

```

> Там же объявлена и неизменяемая реализация `SimpleImmutableEntry`.

Также существуют еще реализации `java.util.Map#Entry` в сторонних библиотеках, например, в `Apache Commons`.

Так вот, `Set<Map.Entry<K, V>> entrySet()` возвращает нам, как мы уже поняли, множество `пар`, хранящихся в `Map`.

Наиболее частый вопрос у тех, кто только начинает знакомиться с `Map`-ами, звучит следующим образом.

---

**Вопрос**:

Как проитерироваться по `Map`? Ведь `java.util.Map` не является `java.lang.Iterable`.

**Ответ**:

Самым простым способом будет взять множество пар и пройтись по этому множеству.

```java
        Map<String, String> map = new HashMap<>();
        map.put("Hello", "World");
        map.put("Hello2", "World2");
        map.put("2", "World3");

        for (Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println(entry);
        }
```

При этом следует помнить, что порядок гарантируеутся не всеми реализациями.
Например, в примере выше первая напечатанная пара будет `2=World3`.

Другой возможный вариант, это получить множество ключей с помощью `Set<K> keySet()` и доставать элементы по ключам, однако предыдущий вариант мне кажется наиболее предпочтительным.

---

### Реализации java.util.Map

Иерархия классов выглядит следующим образом:

![](https://user-images.githubusercontent.com/4215285/73643380-70c7ef80-4684-11ea-8413-a5623fbafa1a.png)

Абстрактный класс `java.util.AbstractMap` предоставляет заготовку для последующих реализаций.

В нем уже определены некоторые методы, достаточные для неизменяемой структуры данных, но такие методы как `put` кидают исключение `java.lang.UnsupportedOperationException`.

Что говорит о том, что операция не поддерживется и ее надо либо не использовать, либо переопределить метод.

Наиболее известные реализации `java.util.Map`:

* [java.util.HashMap](./hash_map.md) - основана на хэш-таблицах.
* [java.util.LinkedHashMap](./linked_hash_map.md) - расширение предыдущей реализации на основе двусвязных списков.
* [java.util.TreeMap](./tree_map.md) - основана на красно-черном дереве.

Существует также реализация `java.util.HashTable`, но она уже давно не используется, во многом благодаря тому, что большинство методов в ней является `synchronized`, что губительо сказывается на производительности.

### Выбор реализации

Когда и какую реализацию выбрать?

Если порядок хранения элементов не важен, то выбор `java.util.HashMap` более чем оправдан.

Данная реализация предоставляет быстрый доступ до элемента, но при условии отсутствия коллизий, т.е хорошо определенной хэш-функции добавляемых элементов, в `Java` за это отвечает метод `hashCode`.

В случае, если порядок добавления элементов важен стоит рассмотреть `java.util.LinkedHashMap`. Понятно, что за сохранение порядка надо платить, поэтому данная реализация работает медленнее, чем `java.util.HashMap`.

Если необходимо, чтобы элементы были отсортированы, то следует присмотреться к `java.util.TreeMap`. Однако в таком случае добавляемые элементы должны либо реализовывать интерфейс `java.lang.Comparable`, либо необходимо написать свой собственный компаратор.

<p class="source">Данный материал основан на главе из книги <a href="https://github.com/qcha/JBook">JBook</a> с разрешения авторов. Подписывайтесь и ставьте звездочки!</p>