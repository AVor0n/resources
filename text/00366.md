## Основы веб

Прежде чем приступить к программированию, мы рассмотрим некоторые принципы веб-разработки, изучив пример приложения по адресу <https://fullstack-exampleapp.herokuapp.com/>.

Приложения реализовано только для демонстрации части базовых концепций курса и ни в коем случае не является примером того, <i>как</i> нужно создавать веб-приложения.
Напротив, оно демонстрирует старые методы веб-разработки, которые в настоящее время можно рассматривать как <i>плохие практики</i>.

Разработка в рекомендуемом стиле начинается с части 1 курса.

<i>Для этой и оставшихся частей</i> используйте браузер Chrome.

Откройте [пример приложения](https://fullstack-exampleapp.herokuapp.com/) в своем браузере. Иногда загрузка можент занять некоторое время.

**1-е правило веб-разработки**: всегда держите консоль разработчика открытой в браузере. В macOS откройте консоль, нажав клавиши `F12` или `alt-cmd-i` (нажмите данную комбинацию одновременно).
В Windows откройте консоль, нажав клавиши `F12` или `ctrl-shift-i` (нажмите данную комбинацию одновременно).

Прежде чем продолжить, узнайте, как открыть консоль разработчика на вашем компьютере (при необходимости лезьте в Google) и не забывайте <i>всегда</i> держать ее открытой при разработке веб-приложений.

Консоль выглядит так:
![](https://github.com/vectree/resources/blob/source/images/00001.png?raw=true)

Убедитесь, что вкладка <i>Network</i> открыта, и установите флажок <i>Disable cache</i>, как показано. Флаг <i>Preserve log</i> также может быть полезен: он сохраняет логи, выведенные приложением при перезагрузке страницы.

**Примечание:** Самая важная вкладка - <i>Console</i>. Однако во введении мы будем чаще использовать вкладку <i>Network</i>.

### HTTP GET

Сервер и веб-браузер обмениваются данными друг с другом по протоколу [HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP). Вкладка Network показывает, как браузер и сервер взаимодействуют.

Когда вы перезагрузите страницу (для этого нажмите клавишу F5 или символ &#8634; в вашем браузере), консоль покажет, что произошло два события:

- Браузер загружает содержимое страницы <i>fullstack-exampleapp.herokuappcom/</i> с сервера.
- И загружает картинку <i>kuva.png</i>

![](https://github.com/vectree/resources/blob/source/images/00002.png?raw=true)

На маленьком экране вам, возможно, придется расширить окно консоли, чтобы увидеть их.

Если у вас маленький экран, вам скорее всего придется увеличить окно консоли, чтобы увидеть все.

Нажатие мышкой на первое событие покажет больше информации о том, что происходит:

![](https://github.com/vectree/resources/blob/source/images/00003.png?raw=true)

Верхняя часть, <i>General</i>, показывает, что браузер выполнил запрос по адресу <i>https://fullstack-exampleapp.herokuapp.com/</i>, используя метод [GET](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET), и что запрос был успешным, поскольку ответ от сервера содержал [двухсотый (200) код состояния](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP).

![](https://github.com/vectree/resources/blob/source/images/00004.png?raw=true)

<i>Response headers</i> показывает размер ответа в байтах и точное время ответа. Важный заголовок [Content-Type](https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Content-Type) сообщает нам, что ответ представляет собой текстовый файл в формате [utf-8](https://ru.wikipedia.org/wiki/UTF-8), содержимое которого отформатировано в соответствии с HTML. Таким образом, браузер знает, что ответом является обычная страница [HTML](https://ru.wikipedia.org/wiki/HTML), и отображает ее «как веб-страницу».

На вкладке <i>Response</i> отображаются данные ответа, в данном случа это обычная HTML-страница. Раздел <i>body</i> определяет структуру страницы, отображаемой на экране:

![](https://github.com/vectree/resources/blob/source/images/00004.png?raw=true)

Страница содержит элемент [div](https://developer.mozilla.org/ru/docs/Web/HTML/Element/div), который, в свою очередь, содержит заголовок, ссылку на страницу <i>notes</i>, тег [img](https://developer.mozilla.org/ru/docs/Web/HTML/Element/img) и отображает количество созданных заметок.

Из-за тега img браузер выполняет второй <i>HTTP-запрос</i>, чтобы получить изображение <i>kuva.png</i> с сервера. Детали запроса:

![](https://github.com/vectree/resources/blob/source/images/00006.png?raw=true)

Запрос был сделан по адресу <https://fullstack-exampleapp.herokuapp.com/kuva.png> и его тип - HTTP GET. Заголовки ответа говорят нам о том, что размер ответа составляет 89350 байт, а его [Content-type](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Type) равен <i>image/png</i>, поэтому полученное изображение имеет формат png. Браузер использует эту информацию для правильного отображения изображения на экране.

Цепочка событий, вызванных открытием страницы https://fullstack-exampleapp.herokuapp.com/ в браузере, формирует следующую [диаграмму последовательности](https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/):

![](https://github.com/vectree/resources/blob/source/images/00007.png?raw=true)

Сначала браузер отправляет HTTP GET-запрос на сервер для получения HTML-кода страницы. Тег <i>img</i> в HTML говорит браузеру загрузить изображение <i>kuva.png</i>. Браузер отображает HTML-страницу и изображение на экране.

Хотя это трудно заметить, HTML-страница начинает отображаться до того, как изображение было получено с сервера.

### Традиционные веб-приложения

Домашняя страница нашего примера работает как <i>традиционное веб-приложение</i>. При входе на страницу браузер загружает HTML-документ, детализирующий структуру и текстовое содержимое страницы с сервера.

Сервер каким-то образом сформировал этот документ. Документ может быть <i>статическим</i> текстовым файлом, сохраненным в каталоге сервера. Сервер также может формировать HTML-документы <i>динамически</i> в соответствии с кодом приложения, используя, например, данные из базы данных.

HTML-код нашего примера формируется динамически, поскольку он содержит информацию о количестве созданных заметок.

HTML-код домашней страницы выглядит следующим образом:

```js
const getFrontPageHtml = (noteCount) => {
  return(`
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Full stack example app</h1>
          <p>number of notes created ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
`)
}

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})
```

Вам пока не нужно понимать этот код.

Содержимое HTML-страницы было сохранено в виде шаблонной строки - строки, которая позволяет вставлять, например, переменные посреди нее. Динамически изменяемая часть домашней страницы - число сохраненных заметок (в коде это <em>noteCount</em>), заменяется текущим количеством заметок (в коде <em> notes.length</em>) в шаблонной строке.

Написание HTML посреди кода, конечно, не очень разумно, но для олдскульных PHP-программистов это была обычная практика.

В традиционных веб-приложениях браузер "глуп". Он только получает данные HTML с сервера, а вся логика приложения находится на сервере. Сервер может быть создан, например, с помощью Java Spring, как на курсе Хельсинкского университета [Web-palvelinohjelmointi](https://courses.helsinki.fi/fi/tkt21007/119558639), с помощью Python Flask, как на курсе [tietokantasovellus](https://materiaalit.github.io/tsoha-18/), или с помощью [Ruby on Rails](http://rubyonrails.org/).

В примере используется [Express](https://expressjs.com/) из Node.js.
Этот курс будет использовать Node.js и Express для создания веб-серверов.

### Запуск логики приложения в браузере

Держите консоль разработчика открытой. Очистите консоль, нажав на символ  &empty;.
Теперь, когда вы перейдете на страницу [notes](https://fullstack-exampleapp.herokuapp.com/notes), браузер выполнит 4 HTTP-запроса:

![](https://github.com/vectree/resources/blob/source/images/00008.png?raw=true)

Все запросы имеют <i>разные</i> типы. Тип первого запроса - <i>document</i>. Это HTML-код страницы, и он выглядит следующим образом:

![](https://github.com/vectree/resources/blob/source/images/00009.png?raw=true)

Когда мы сравним страницу, отображаемую в браузере, и HTML-код, возвращаемый сервером, мы заметим, что этот код не содержит списка заметок.
Раздел [head](https://developer.mozilla.org/ru/docs/Web/HTML/Element/head) HTML-кода содержит [script](https://developer.mozilla.org/ru/docs/Web/HTML/Element/script)-тег, который говорит браузеру загрузить JavaScript-файл с именем <i>main.js</i>.

Код JavaScript выглядит следующим образом:

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementById('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```

Детали работы этого кода сейчас не важны, но в нем была добавлена логика, которая оживляет изображения и текст. Мы как следует начнем разработку в 1 части курса. Пример кода в этой части на самом деле не соответствует методам разработки приложений в данном курсе.

> Некоторые могут задаться вопросом, почему вместо современного fetch используется объект xhttp. Это связано с тем, что мы не хотим вдаваться в  тему promise'ов, так как код играет второстепенную роль в этой части. Мы вернемся к современным способам отправки запросов на сервер во второй части.

Сразу после загрузки файла из тега <i>script</i> браузер начинает выполнять код.

Последние две строки определяют, что браузер выполняет HTTP GET-запрос к адресу сервера <i>/data.json</i>:

```js
xhttp.open('GET', '/data.json', true)
xhttp.send()
```

Это самый нижний запрос, отображаемый на вкладке Network.

Мы можем попробовать перейти по адресу <https://fullstack-exampleapp.herokuapp.com/data.json> прямо из браузера:

![](https://github.com/vectree/resources/blob/source/images/00010.png?raw=true)

Там мы найдем "необработанные данные" в формате [JSON](https://ru.wikipedia.org/wiki/JSON). Это наши заметки.
По умолчанию браузер не подходит для отображения JSON-данных. Различные плагины могут быть использованы для форматирования. Установите, например, [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) в Chrome и перезагрузите страницу. Данные станут лучше отформатироваными:

![](https://github.com/vectree/resources/blob/source/images/00011.png?raw=true)

Итак, JavaScript-код страницы заметок (notes) загружает JSON-данные, содержащие заметки, и формирует список.

Это делается с помощью следующего кода:

```js
const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)
```

Сначала код создает неупорядоченный список с помощью [ul](https://developer.mozilla.org/ru/docs/Web/HTML/Element/ul)-тега...

```js
var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')
```

... а затем добавляет по одному [li](https://developer.mozilla.org/ru/docs/Web/HTML/Element/li)-тегу для каждой заметки. Только поле <i>content</i> каждой заметки становится содержимым тега li. Временные метки, полученные при загрузке необработанных данных, здесь ни для чего не используются.

```js
data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```

Теперь откройте вкладку <i>Console</i> на консоли разработчика:

![](https://github.com/vectree/resources/blob/source/images/00012.png?raw=true)

Нажав на маленький треугольник в начале строки, вы можете развернуть текст на консоли.

![](https://github.com/vectree/resources/blob/source/images/00013.png?raw=true)

Этот вывод в консоль вызван командой <em>console.log</em>:

```js
const data = JSON.parse(this.responseText)
console.log(data)
```

Итак, после получения данных с сервера, код выводит их на консоль.

Вкладка <i>Консоль</i> и команда <em>console.log</em> станут вам, как подными, в ходе курса.

### Обработчики событий и функции обратного вызова (callback)

Структура этого кода немного странная:

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // код, отвечающий за ответ от сервера
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```

Запрос к серверу отправляется в последней строке, но код для обработки ответа можно найти выше. Что происходит?

На этой строке,

```js
xhttp.onreadystatechange = function () {
```

определен <i>обработчик</i> события <i>onreadystatechange</i> для объекта <em>xhttp</em>, выполняющего запрос. Когда состояние (state) объекта изменяется, браузер вызовет функцию обработки события. Код функции проверяет, что [readyState](https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState) равно 4 (отображает ситуацию, когда <i>операция завершена</i>) и что код состояния HTTP ответа равен 200.

```js
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // код, отвечающий за ответ от сервера
  }
}
```

Механизм вызова обработчиков событий очень распространен в JavaScript. Функции обработки событий называются функциями [обратного вызова](https://developer.mozilla.org/ru/docs/Glossary/Callback_function) или callback-функциями. Ваш код не вызывает сами функции, но среда выполнения - браузер вызывает функцию в соответствующее время, когда произошло указанное вами <i>событие</i>.

### Document Object Model или DOM

Мы можем думать о HTML-страницах как о неявных древовидных структурах.

<pre>
html
  head
    link
    script
  body
    div
      h1
      div
        ul
          li
          li
          li
      form
        input
        input
</pre>

Подобную древовидную структуру можно увидеть на вкладке консоли <i>Elements</i>.

![](https://github.com/vectree/resources/blob/source/images/00014.png?raw=true)

Функционирование браузера основано на идее представления элементов HTML в виде дерева.

Document Object Model, или [DOM](https://ru.wikipedia.org/wiki/Document_Object_Model) - это программный интерфейс приложения (<i>API</i>), который позволяет программно изменять <i>деревья элементов</i>, соответствующие веб-страницам.

Код JavaScript, представленный в предыдущей главе, использовал DOM-API для добавления списка заметок на страницу.

Следующий код создает новый <em>ul</em>-узел и добавляет к нему несколько дочерних узлов:

```js
var ul = document.createElement('ul')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```

Наконец, вся ветвь <em>ul</em>, включая <em>li</em>, добавляется в HTML-дерево всей страницы:

```js
document.getElementById('notes').appendChild(ul)
```

### Управление объектом document из консоли

Самый верхний узел дерева DOM HTML-документа называется объектом <em>document</em>. Мы можем выполнять различные операции на веб-странице, используя DOM-API. Вы можете получить доступ к объекту <em>document</em>, введя <em>document</em> на вкладке Console:

![](https://github.com/vectree/resources/blob/source/images/00015.png?raw=true)

Давайте добавим на нашу страницу заметку из консоли.

Сначала давайте получим список уже существующих заметок страницы. Этот список находится в первом ul-элементе страницы:

```js
list = document.getElementsByTagName('ul')[0]
```

Затем создайте новый li-элемент и добавьте в него текстовый контент:

```js
newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'
```

И добавьте li-элемент в список:

![](https://github.com/vectree/resources/blob/source/images/00016.png?raw=true)

Даже если страница обновилась в вашем браузере, выполненные изменения не будут постоянными. Если перезагрузить страницу, то созданная заметка исчезнет, поскольку изменения не были переданы и сохранены на сервере. JavaScript-код, который загружает браузер, всегда создает список заметок на основе JSON-данных, полученных с адреса <https://fullstack-exampleapp.herokuapp.com/data.json>.

### CSS

Элемент <i>head</i> нашей HTML-страницы содержит тег [link](https://developer.mozilla.org/ru/docs/Web/HTML/Element/link), который дает задачу браузеру загрузить таблицу стилей [CSS](https://developer.mozilla.org/ru/docs/Web/CSS) по адресу [main.css](https://fullstack-exampleapp.herokuapp.com/main.css).

Каскадные таблицы стилей (CSS) - это язык разметки, используемый для определения внешнего вида веб-приложений.

Загруженныый CSS-файл выглядит следующим образом:

```css
.container {
  padding: 10px;
  border: 1px solid;
}

.notes {
  color: blue;
}
```

Этот файл определяет два [селектора по классу](https://developer.mozilla.org/ru/docs/Web/CSS/Class_selectors). Они используются для оформления и стилизации определенных частей страницы.

Синтаксис селектора по классу всегда начинается с точки и содержит имя класса.

Классами являются [атрибуты](https://developer.mozilla.org/ru/docs/Web/HTML/Global_attributes/class), которые можно добавлять в HTML-элементы.

CSS-атрибуты можно изучить на вкладке <i>Elements</i> консоли:

![](https://github.com/vectree/resources/blob/source/images/00017.png?raw=true)

Верхний элемент <i>div</i> имеет класс <i>container</i>. Элемент <i>ul</i>, содержащий список заметок, имеет класс <i>notes</i>.

Правило CSS определяет, что элементы с классом <i>container</i> будут выделены с помощью [границы](https://developer.mozilla.org/ru/docs/Web/CSS/border) (border) шириной в один пиксель. Оно также устанавливает [внутренний отступ](https://developer.mozilla.org/ru/docs/Web/CSS/padding) (padding) в 10 пикселей для элемента. В результате вы увидите пустое пространство между содержимым элемента и границей.

Второе CSS-правило задает синий цвет текста заметок.

HTML-элементы могут иметь и другие атрибуты, не только классы. Элемент <i>div</i>, содержащий примечания, имеет атрибут [id](https://developer.mozilla.org/ru/docs/Web/HTML/Global_attributes/id). JavaScript-код использует этот идентификатор для поиска элемента.

Вкладка <i>Elements</i> консоли браузера может использоваться для изменения стилей элементов.

![](https://github.com/vectree/resources/blob/source/images/00018.png?raw=true)

Изменения, сделанные в консоли, не будут постоянными. Если вы хотите внести изменения на постоянной основе, они должны быть сохранены в таблице стилей CSS на сервере.

### Загрузка страницы, содержащей JavaScript - повторим изученное

Давайте повторим, что происходит, когда в браузере открывается страница https://fullstack-exampleapp.herokuapp.com/notes.

![](https://github.com/vectree/resources/blob/source/images/00019.png?raw=true)

- Браузер загружает HTML-код, определяющий содержимое и структуру страницы. Загрузка происходит с сервера, используя HTTP-запрос GET.
- Ссылки в HTML-коде заставляет браузер загружать таблицу стилей CSS по адресу <i>main.css</i>...
- ...и JavaScript-код и файла <i>main.js</i>.
- Браузер запускает код JavaScript. В коде выполняется HTTP GET-запрос по адресу https://fullstack-exampleapp.herokuapp.com/data.json, который возвращает заметки в виде JSON-данных.
- Когда данные загружаются, браузер выполняет <i>обработчик событий</i>, который отображает заметки на странице с использованием DOM-API.

### Формы и HTTP POST

Давайте теперь рассмотрим, как выполняется добавление новой заметки.

Страница заметок содержит [элемент формы](https://developer.mozilla.org/ru/docs/Learn/HTML/Forms/Your_first_HTML_form)

![](https://github.com/vectree/resources/blob/source/images/00020.png?raw=true)

При нажатии кнопки формы браузер отправит введенные пользователем данные на сервер. Давайте откроем вкладку <i>Network</i> и посмотрим, как выглядит отправка формы:

![](https://github.com/vectree/resources/blob/source/images/00021.png?raw=true)

Удивительно, но отправка формы вызывает всего <i>пять</i> HTTP-запросов.
Первый - это событие отправки формы. Давайте увеличим масштаб:

![](https://github.com/vectree/resources/blob/source/images/00022.png?raw=true)

Это [HTTP POST-запрос](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST) по адресу сервера <i>new\_note</i>. Сервер отвечает HTTP-кодом 302. Это [Перенаправление URL](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_URL), с помощью которого сервер просит браузер выполнить новый HTTP GET-запрос на адрес <i>notes</i>, указанный в заголовке <i>Location</i>.

В результате, браузер перезагрузит страницу заметок. Перезагрузка вызовет еще три HTTP-запроса: загрузку таблицы стилей (main.css), кода JavaScript (main.js) и заметок - необработанных данных (data.json).

На вкладке Network (Сеть) также отображаются данные, которые мы отправили из формы:

![](https://github.com/vectree/resources/blob/source/images/00023.png?raw=true)

Тег form имеет атрибуты <i>action</i> и <i>method</i>, которые определяют, что при отправке формы будет выполнен HTTP POST-запрос на адрес <i>new_note</i>.

![](https://github.com/vectree/resources/blob/source/images/00024.png?raw=true)

Код на сервере, обрабатывающий данный POST-запрос, достаточно прост (примечание: этот код находится на сервере, а не в JavaScript-коде, полученном браузером):

```js
app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})
```

Данные отправляются в [body](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST) POST-запроса.

Сервер может получить доступ к этим данным, обратившись к полю <em>req.body</em> объекта запроса <em>req</em>.

Сервер создает новый объект заметки и добавляет его в массив с именем <em>notes</em>.

```js
notes.push({
  content: req.body.note,
  date: new Date(),
})
```

Объект заметки имеет два поля: <i>content</i>, содержащее текст заметки, и <i>date</i>, содержащее дату и время создания заметки.
Сервер не сохраняет новые заметки в базе данных, поэтому созданные заметки исчезают, когда Heroku перезапускает сервис.

### AJAX

Страница заметок использует Ajax и соответствует стилю веб-разработки, существовавшему в ранние годы. Таким образом, она находится на гребне волны веб-технологий начала 2000-х годов.

[AJAX](https://ru.wikipedia.org/wiki/AJAX) (Asynchronous Javascript and XML) - это термин, введенный в феврале 2005 года для описания нового революционного подхода, который позволял загружать контент веб-страницы с помощью JavaScript без необходимости перезагрузки всей страницы.

До AJAX-эры все веб-страницы работали аналогично традиционному веб-приложению, которое мы рассматривали ранее в этой главе.
Все данные, показанные на странице, были получены с помощью HTML-кода, сгенерированного сервером.

Страница заметок использует AJAX для получения данных. Но для отправки формы по-прежнему используется традиционный механизм отправки веб-форм.

URL-адреса приложения отражают старые, беззаботные времена. JSON-данные извлекаются с URL-адреса <https://fullstack-exampleapp.herokuapp.com/data.json>, а новые заметки отправляются на URL-адрес <https://fullstack-exampleapp.herokuapp.com/new_note>.
В настоящее время подобные URL-адреса не будут считаться приемлемыми, поскольку они не соответствуют общепризнанным соглашениям [RESTful](https://ru.wikipedia.org/wiki/REST) API, которые мы рассмотрим подробнее в третьей  части.

То, что называется AJAX, стало настолько обычным явлением, что это стало само собой разумеющимся. Термин исчез в забвении, и новое поколение разработчиков даже не слышало о нем.

### Single page app

В нашем примере домашняя страница работает как традиционная веб-страница: вся логика находится на сервере, а браузер отображает HTML только в соответствии с инструкциями.

На странице заметок же ответственность за создание HTML-кода для уже существующих заметок передается браузеру. Браузер решает эту задачу, выполняя код JavaScript, полученный с сервера. Код извлекает заметки с сервера в виде JSON-данных и добавляет HTML-элементы для отображения заметок на странице с помощью [DOM-API](/ru/part0/fundamentals_of_web_apps#document-object-model-или-dom).

В последние годы появился новый подход к созданию веб-приложений - [Single-page application](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5) (SPA иди одностраничные приложения). SPA-сайты не загружают все свои страницы с сервера, как это делается в нашем примере, и вместо этого состоят только из одной HTML-страницы, извлекаемой с сервера. Содержимое это страницы генерируется и изменяется с помощью JavaScript, который выполняется непосредственно в браузере.

Страница заметок нашего примера имеет некоторое сходство с приложениями в стиле SPA. Несмотря на то, что логика рендеринга (отрисовки) заметок выполняется в браузере, на странице все еще используется традиционный способ добавления новых заметок. Данные отправляются на сервер с помощью формы, и сервер дает инструкцию браузеру перезагрузить страницу заметок с помощью <i>редиректа - переадресации</i>.

Одностраничную версию нашего примера можно найти по адресу <https://fullstack-exampleapp.herokuapp.com/spa>.
На первый взгляд приложение выглядит точно так же, как и предыдущее.
HTML-код почти идентичен, но файл JavaScript отличается (<i>spa.js</i>), и в теге form есть небольшое изменение:

![](https://github.com/vectree/resources/blob/source/images/00025.png?raw=true)

В теге form не указаны атрибуты <i>action</i> и <i>method</i>, которые определяют, как и куда отправлять введенные данные.

Откройте вкладку <i>Network</i> и очистите ее, щелкнув по сиволу &empty. Теперь, когда вы создадите новую заметку, вы заметите, что браузер отправляет только один запрос на сервер.

![](https://github.com/vectree/resources/blob/source/images/00026.png?raw=true)

POST-запрос по адресу <i>new\_note\_spa</i> отправляет данные в формате JSON. Эти данные содержат текст заметки (<i>content</i>) и дату создания заметки (<i>date</i>):

```js
{
  content: "single page app does not reload the whole page",
  date: "2019-05-25T15:15:59.905Z"
}
```

Заголовок <i>Content-Type</i> запроса сообщает серверу, что передаваемые данные представлены в формате JSON.

![](https://github.com/vectree/resources/blob/source/images/00027.png?raw=true)

Без этого заголовка сервер не понял бы, как правильно анализировать данные.

В итоге, сервер отвечает кодом состояния [201 created](https://httpstatuses.com/201). На этот раз сервер не запрашивает переадресацию, браузер остается на той же странице и больше не отправляет HTTP-запросы.

SPA-приложение не отправляет данные формы традиционным способом, а использует код JavaScript, полученный с сервера.
Мы немного рассмотрим этот код, хотя понимание всех его деталей пока не важно.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
```

Команда <em>document.getElementById('notes\_form')</em> предписывает извлечь элемент формы со страницы и зарегистрировать <i>обработчик</i> события отправки формы. Обработчик события немедленно вызывает метод <em>e.preventDefault()</em>, чтобы предотвратить обработку отправки формы по умолчанию. Ведь по умолчанию после отправки данных на сервер вызывается перенаправление, чего мы не хотим.

Затем обработчик события создает новую заметку, добавляет ее в список с помощью команды <em>notes.push(note)</em>, перерисовывает список заметок на странице и в конце отправляет новую заметку на сервер.

Код отправки заметки на сервер выглядит следующим образом:

```js
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}
```

Данный код определяет, что данные должны отправляться HTTP POST-запросом в формате JSON. Тип данных определяется с помощью заголовка <i>Content-type</i>. В итоге данные отправляются в виде JSON-строки.

Код приложения доступен по адресу <https://github.com/mluukkai/example_app>.
Стоит помнить, что приложение предназначено только для демонстрации концепций курса. Код в некоторой степени придерживается плохого стиля разработки и не должен использоваться в качестве примера при создании собственных приложений. То же самое относится и к используемым URL. URL-адрес <i>new\_note\_spa</i>, на который отправляются новые заметки, не соответствует рекомендациям.

### Библиотеки JavaScript

В нашем примере все построенно на так называемом [vanilla Javascript](https://medium.freecodecamp.org/is-vanilla-javascript-worth-learning-absolutely-c2c67140ac34), то есть с использованием только DOM-API и JavaScript для управления структурой страницы.

Вместо использования только JavaScript и DOM-API для манипулирования страницами часто используются различные библиотеки, содержащие инструменты, с которыми легче работать по сравнению с DOM-API. Одна из этих библиотек - очень популярная [JQuery](https://jquery.com/).

JQuery был разработан тогда, когда веб-страницы в основном следовали традиционному стилю, где сервер генерировал HTML-страницы, а JavaScript с JQuery на стороне браузера расширял функциональность. Одной из причин успеха JQuery была его так называемая кросс-браузерная совместимость. Библиотека работала независимо от браузера или компании, которая его создала, поэтому не было необходимости в конкретных браузерных решениях. В настоящее время использование JQuery не так оправдано, учитывая прогресс VanillaJS, ведь наиболее популярные браузеры хорошо поддерживают основные функции.

Появление SPA привнесло больше "современных" подходов к веб-разработке, чем JQuery. Фаворитом первой волны был [BackboneJS](http://backbonejs.org/). После в 2012 году [появился](https://github.com/angular/angular.js/blob/master/CHANGELOG.md#100-temporal-domination-2012-06-13) [AngularJS](https://angularjs.org/) от Google, который быстро стал практически де-факто стандартом современной веб-разработки.

В настоящее время самым популярным инструментом для реализации логики веб-приложений на стороне браузера является библиотека [React](https://reactjs.org/) от Facebook.
Во время этого курса мы познакомимся с React и библиотекой [Redux](https://github.com/reactjs/redux), которые часто используются вместе.

Позиции React кажутся сильными, но мир JavaScript постоянно меняется. Например, недавно новичок [VueJS](https://vuejs.org/) привлек к себе большой интерес со стороны разработчиков.

### Full stack веб-разработка

Что значит название курса <i>Full stack веб-разработка</i>? Full stack - модное слово, о котором все говорят, хотя никто не знает, что это значит. Или, по крайней мере, не существует согласованного определения термина.

Практически все веб-приложения имеют (как минимум) два «слоя»: браузер, находящийся ближе к конечному пользователю, является верхним слоем, а сервер - нижним. Часто под сервером также находится слой базы данных. Поэтому мы можем думать о <i>архитектуре</i> веб-приложения как о неком <i>стеке</i> слоев.

Часто мы также говорим о [frontend](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4_%D0%B8_%D0%B1%D1%8D%D0%BA%D0%B5%D0%BD%D0%B4) и [backend](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4_%D0%B8_%D0%B1%D1%8D%D0%BA%D0%B5%D0%BD%D0%B4). Браузер является frontend'ом (внешним интерфейсом), а запускаемый в браузере JavaScript - кодом frontend'а. Сервер с другой стороны является backend'ом.

В контексте этого курса full stack веб-разработка означает, что мы сосредоточены на всех частях приложения: на интерфейсе, на сервере и на базе данных. Иногда программное обеспечение сервера и операционной системы тоже рассматриваются как части стека, но мы не будем вдаваться в них.

Мы будем разрабатывать backend с помощью JavaScript, используя среду выполнения [Node.js](https://nodejs.org/en/). Использование одного и того же языка программирования на нескольких уровнях стека дает full stack разработке совершенно новый взгляд. Но в веб-разработке не требуется использовать для всех слоев стека один и тот же язык программирования (JavaScript).

Раньше разработчики чаще специализировались на одном слое стека, например, на бэкенде. Технологии на бэкэнде и фронтэнде были совершенно разными. С появлением full stack тренда разработчики стали разбираться во всех уровнях приложения, включая базу данных. Зачастую full stack разработчики даже должны обладать достаточными навыками конфигурирования и администрирования, чтобы управлять своим приложением, например, в облаке.

### Усталость от Javascript

Full stack веб-разработка сложна во многих отношениях. Разные вещи происходят во многих местах одновременно, и отладка становится немного сложнее, чем в обычных desktop-приложениях. JavaScript не всегда работает так, как вы ожидаете (по сравнению со многими другими языками), и асинхронный способ работы его сред выполнения вызывает много разных видов проблем. Общение в сети требует знания HTTP-протокола. Нужно также уметь работать с базами данных, администрированием и настройкой серверов. Также хорошо было бы знать CSS на базовом уровне, чтобы сделать приложения хотя бы чуть чуть презентабельными.

Мир JavaScript развивается быстро, что ставит новые задачи. Инструменты, библиотеки и сам язык находятся в постоянном развитии. Некоторые начинают уставать от постоянных изменений и придумали для них термин: [Усталость](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4) [от JavaScript](https://auth0.com/blog/how-to-manage-javascript-fatigue/).

Вы устанете от JavaScript во время этого курса. К счастью для вас, есть несколько способов сгладить кривую обучения, и мы можем начать с разработки, а не с конфигурации. Мы не можем полностью избежать конфигурации, но мы можем весело продвигаться вперед в течение следующих нескольких недель, избегая худшего из конфигурационных адов.