## Поэзия NodeJS

> Данный перевод на доработке. В ближайшее время он будет исправляться и актуализироваться.

Итак, вы разобрали основы NodeJS. В статье мы еще раз пройдемся по всем основным моментам, связанным с данной технологией.

### Изучите NodeJS интерактивно

В дополнение к чтению, очень важно параллельно писать код. Так вы скорее проникнетесь духом NodeJS и вникнете в её суть. Читать код в книгах важно и нужно, но обучение через написание кода - это ещё более лучший способ познания новых принципов программирования.

### NodeSchool.io

[NodeSchool.io](http://nodeschool.io/) - серия открытых интерактивных воркшопов, по которым можно обучиться основным принципам NodeJS.

[Learn You The Node.js](https://github.com/workshopper/learnyounode#learn-you-the-nodejs-for-much-win) представляет собой вступительный воркшоп NodeSchool.io. Здесь собраны несколько задач, решение которых поможет вам усвоить основные принципы построения программ для NodeJS.

[![learnyounode](https://user-images.githubusercontent.com/4215285/71118519-5ecfe180-21e9-11ea-86c8-a8111f96b6a8.png)](https://github.com/rvagg/learnyounode#learn-you-the-nodejs-for-much-win)

Устанваливается как консольная утилита через npm:

```
# install
npm install learnyounode -g

# start the menu
learnyounode
```

### Путь к пониманию NodeJS

NodeJS - open source проект, созданный помочь вам писать программы для работы с сетью, файловыми системами и другими I/O (input/output, reading/writing) на языке JavaScript. Вот и всё! Это простая и стабильная I/O платформа, в которой удобно создавать свои модули.

Какие ещё есть примеры использования ввода/вывода (далее I/O)? Здесь показана схема приложения на NodeJS; на ней видно какие могут быть I/O источники:

![server diagram](https://user-images.githubusercontent.com/4215285/71118525-62636880-21e9-11ea-83cc-b58a4174a1a2.png)

Если вы не знаете все источники представленные на схеме, ничего страшного. Суть в том, чтобы показать, что один единственный процесс NodeJS (шестигранник в центре) может выполнять роль диспетчера между разными конечными точками (endpoints) I/O (оранжевым и фиолетовым обозначены каналы ввода/вывода).

Обычно, построение систем такого вида идет по одному из путей:

- сложно для написания, но в результате получается производительная система (подобно написанию своих веб-серверов на чистом C);
- просты в написании, но сильно страдают в скорости работы (особенно, когда кто-то пытается отправить на сервер файл 5Гб и сервер падает).

Задача NodeJS - сохранить равновесие при достижении двух целей: быть достаточно простой для понимания, использования и настолько же быстрой для решения большинства задач.

NodeJS не является:
 - веб-фреймворком (вроде Rails или Django, хотя и может использоваться для создания подобных вещей);
 - языком программирования (NodeJS использует JS, но сама NodeJS языком **НЕ** является).

NodeJS - нечто среднее, можно сказать, что NodeJS:

  - Сделана чтобы быть простой для понимания и использования;
  - Удобной при создании I/O программ, которые должны работать быстро и оставаться устойчивыми к высоким нагрузкам.
  
На более низком уровне, NodeJS можно назвать инструментом для написания двух типов программ:

  - Сетевые программы, использующие протоколы веба: HTTP, TCP, UDP, DNS и SSL;
  - Программы, для чтения и записи данных в файловую систему (далее **ФС**) или локальные процессы / память.

Что означает "программы для I/O (Ввод/Вывод)? Рассмотрим несколько основых источников Ввода/Вывода:

  - Базы данных (MySQL, PostgreSQL, MongoDB, Redis, CouchDB);
  - Внешние API (Twitter, Facebook, Apple Push Notifications);
  - HTTP/WebSocket соединения (от пользователей веб-приложений);
  - Файлы (сжатие изображений, редактирование видео, интернет-радио).

NodeJS выполняет операции ввода/вывода способом, который называют [асинхронным](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4). Такой способ позволяет ей выполнять много разных операций одновременно. Приведем небольшой пример для понимания. Например, зайдя в какой-нибудь фаст-фуд и заказав чизбургер, ваш заказ примут *сразу*, и после *небольшой задержки* заказ будет готов. Пока вы ждете, они могут принимать другие заказы и начать готовить чизбургеры для других людей. А теперь представьте ситуацию, когда остальным людям в очереди придется ждать, пока вам не принесут чизбургер. Они не смогут сделать заказ, пока вам его не приготовят! Технически такое поведение называется **блокирующая очередь**, ведь все операции ввода/вывода (по приготовлению чизбургеров) происходят строго по одной в момент времени. NodeJS же, наоборот, реализует механизм **неблокирующей очереди**, что позволяет готовить много чизбургеров одновременно.

На NodeJS такие вещи можно реализовать довольно легко, благодаря её неблокирующей сущности. Примеры:
  
  - Механизм управления [летающими квадракоптерами](http://www.nodecopter.com/);
  - IRC чат-бот;
  - [Ходячие роботы](https://www.youtube.com/watch?v=jf-cEB3U2UQ).

### Базовые модули

Во-первых, установите NodeJS себе на компьютер. Брать её лучше отсюда [nodejs.org](http://nodejs.org).

У NodeJS есть небольшая группа (ее обычно называют термином - ядро NodeJS) базовых модулей, которые представлены, как внешний API для написания программ. Каждый модуль предназначен для своих целей: для работы с файловой системой есть модуль `fs`, для работы с сетями `net` (TCP), `http`, `dgram` (UDP).

Помимо модуля `fs` и сетевых модулей, есть и другие базовые модули:
- для асинхронной работы с DNS-запросами есть модуль `dns`;
- `os` - для получения данных об операционной системе;
- для выделения бинарных фрагентов памяти есть `buffer`;
- модули для различного рода парсинга урлов, путей к файлам (`url`, `querystring`, `path`). 

Большинство из базовых модулей, если не все, служат для одной общей цели - написание быстрых (!) программ для работы с файловой системой или сетью.

NodeJS обрабатывает I/O-операции используя: колбэки, события, потоки и модули. Если вы знаете как они работают, то сможете разобраться в любом базовом модуле и понять, как его правильно использовать.

### Колбэки

> Не смотря на то, что в NodeJS присутствует await / async, с помощью коллбеков проще понять природу NodeJS. Поэтому мы и поговорим о них.

Это, пожалуй, самая важная часть всего гайда. Если хотите понять, как работает NodeJS, придется разобраться с колбэками. Колбэки используются в NodeJS повсюду и по сути являются частью языка JavaScript.

Итак, начнем с определения. Колбэки - функции, которые вызываются не по мере выполнения основного кода - сразу, а асинхронно, т.е. их *выполнение* будет отложено. В отличие от привычного процедурного стиля написания и выполнения кода **сверху вниз**, асинхронные программы могут выполнять свои функции непоследовательно (не в порядке их написания), учитывая скорость выполнения предыдущих функций, например http-запросов или чтения с диска.

Поначалу такое отличие попросту сбивает с толку. Действительно, бывает трудно определить заранее, будет ли функция выполняться асинхронно или нет - во многом это зависит от контекста её выполнения. Разберем простой пример синхронного выполнения, где код будет выполняться последовательно сверху вниз:

```js
let myNumber = 1;
function addOne() { // определяем функцию
    myNumber++; 
}
addOne(); // выполняем функцию
console.log(myNumber); // 2
```

В коде определяется функция и на след строке происходит её вызов, без задержек и пауз. Когда функция вызывается, `myNumber` *сразу* увеличится на 1. Мы уверены, что после вызова функции число станет равным `2`. Это и есть предсказуемость синхронного кода - он всегда выполняется последовательно сверху вниз.

NodeJS же часто использует асинхронную модель выполнения кода. Давайте с помощью NodeJS прочитаем число из файла `number.txt` (файл находится на диске, а значит будем использовать модуль `fs` - прим. перев.):

```js
const fs = require('fs'); // подключение модуля для работы с ФС
let myNumber = undefined; // пока мы не знаем какое число записано в файле

function addOne() {
  fs.readFile('number.txt', function doneReading(err, fileContents) {
    myNumber = parseInt(fileContents);
    myNumber++;
  });
}

addOne();

console.log(myNumber); // undefined -- эта строка выполнится до того, как будет прочитан файл!
```

Почему же после вызова функции мы получили `undefined`? Обратите внимание, в коде мы используем асинхронный метод `fs.readFile`. Обычно, такие функции, где идут операции чтения-записи на диск или работа с сетью, делают асинхронными. Когда же требуется обратиться к памяти напрямую или поиспользовать возможности процессора, то функции делают синхронными. И связанно это с тем, что операции I/O невероятно медленные (это относится не только к NodeJS, но и ко всем языкам и технологиям - прим. перев). Стоит сказать, что чтение с жесткого диска происходит медленнее чем из памяти (RAM) - примерно в **100 тысяч раз**.

Когда мы запустим эту программу, определение функций произойдет немедленно, но такая быстрота не относится к скорости их выполнения. Это ключевой принцип для понимания асинхронного программирования. Когда произойдет вызов `addOne` она следом запустит функцию `readFile`, но не будет ждать окончания её работы, а перейдет к следующей задаче. Если NodeJS больше нечего выполнять она будет просто ждать окончания IO-операций чтобы закончить работу и выйти.

Далее, когда `readFile` прочитает файл (это может занять некоторое время от нескольких миллисекунд до нескольких секунд или даже минут, в зависимости от того как быстро происходит чтение с диска), следом будет выполняться функция `doneReading`, которая и выдаст содержимое файла (если чтение прошло успешно) или ошибку.

В нашей программе мы получили на выходе `undefined`, потому что в коде нет никаких явных указаний функции `console.log` дождаться окончания выполнения `readFile` перед тем как выводить число.

Если вы хотите, чтобы какой-то код гарантированно выполнился последовательно, сперва поместите этот код в коллбек функцию! Только после этого вы сможете вызвать функцию (выполнить блок кода) там, где необходимо. Это должно подтолкнуть вас давать функциям точные и понятные имена.

Важно запомнить, что колбэки - просто функции, которые выполнятся не сразу - по мере чтения кода, а когда произойдет определенное событие. Ключ к пониманию механизма коллбэков лежит в том, что вы никогда не узнаете, *когда* (в какой момент времени) закончится асинхронная операция (I/O), но вы будете уверены в том, после какого события операция закончится! Порядок объявления колбэков не имеет никакого значения и не влияет на последовательность выполнения. Значение имеет только их логическая вложенность, иерархичность если хотите. Сперва вы разбиваете свой код на функции (обособленные части кода) и только потом используете колбэки, чтобы описать зависмости между их вызовами.

Снова вернемся к программе. Метод `fs.readFile`, предлагаемый NodeJS, выполняется асинхронно и требует много времени для своего выполнения. Рассмотрим происходящее детально: для выполнения функции требуется обратиться к операционной системе => которой надо обратиться к файловой системе => которая живет на диске => который совершает тысячи оборотов в минуту. Диску надо задействовать магнитную головку, (а это уже физический уровень, между прочим) чтобы прочитать данные и отправить их обратно по всем уровням нашей программе. Вы передаете методу `readFile` функцию-колбэк и она будет вызвана после того, как данные от ФС будут получены. NodeJS поместит полученные данные в переменную и только теперь вызовет вашу функцию-коллбэк с нужным значением переменной (не `undefined`). В этом случае переменная называется `fileContents`, т.к. в ней лежит содержимое всего файла.

Вспомните пример с заказом, чикенбургерами и очередью из начала. Во многих ресторанах вам ставят на стол номер, пока вы ждете свой заказ. Это очень похоже на коллбэк. Эти номера говорят официантам, что нужно сделать когда ваш заказ будет готов.

Вернемся к нашему примеру и вынесем выражение `console.log` в отдельную функциию и передадим её как коллбэк:

```js
const fs = require('fs');
let myNumber = undefined;

function addOne(callback) {
  fs.readFile('number.txt', function doneReading(err, fileContents) {
    myNumber = parseInt(fileContents);
    myNumber++;
    callback(); // наш коллбек
  });
}

function logMyNumber() {
  console.log(myNumber);
}

addOne(logMyNumber);
```

Теперь функцию `logMyNumber` можно передать как аргумент, который станет "колбэчной" переменной уже внутри функции `addOne`. После окончания выполнения `readFile` будет вызвана переменная `callback` (именно вызвана как функция: `callback()`). Вызываться могут только фукнции, так что, если передать туда что-то другое, то это приведет к ошибке.

В JS когда функция вызывается внутри другой функции (как `callback()`), она будет выполнена сразу. В нашем примере произойдет вывод числа `myNumber`, так как вызов `callback` по сути есть вызов переданной функции `logMyNumber`. Запонмите важную вещь, когда вы *определяете* функцию, это ещё ничего не говорит о том, когда она будет вызвана. Чтобы она сработала надо явно вызвать ее.

Чтобы окончательно закончить разбор нашего пример, выпишем все действия в той последовательности, в которой они выполнятся при запуске программы:

1. Код спарсится и, если в нем есть синтаксические ошибки, программа не запустится. В процессе парсинга будут определены переменные `fs` и `myNumber` и функции `addOne` и `logMyNumber`. Заметьте, что на этом этапе идут только определения. Ни одна функция пока не вызвана.
2. Когда выполнится последняя строка программы, будет вызвана функция `addOne` с параметром `logMyNumber` в качестве колбэка. Вызов `addOne` приведет к запуску асинхронную функцию `fs.readFile`. Этой части программы нужно время, чтобы завершиться.
3. NodeJS будет какое-то время бездействовать и ждать пока выполнится функция `readFile`. Если бы у неё были ещё какие-то задачи, она занялась бы ими.
4. Как только `readFile` заканчивает работу, в дело вступает колбэк-функция `doneReading`, которая парсит `fileContents` и ищет целое число. Результат `parseInt` присваивается `myNumber` и увеличивает его (`myNumber`) значение на 1. Затем сразу вызывается функция `logMyNumber`, переданная как параметр `callback` в `addOne`.

Пожалуй самая непривычная часть программирования с колбэками - это то, как функции (подобно объектам) могут храниться в переменных и передаваться под разными именами. Давать простые и понятные имена своим переменным - очень важное умение для программиста, особенно когда он пишет код, который будут читать другие люди. Читая NodeJS-программы, если вы видите переменную с именем `callback` или `cb` - скорее всего здесь ожидается функция-колбэк.

Вы наверняка слышали такие понятия, как событийно-ориентированное программирование или **event loop** (или событийный цикл). Они обозначают способ, с помощью которого реализован `readFile`. Сначала NodeJS отправляет на выполнение метод `readFile`, потом ждет от него событие (event) о своем окончании. В процессе ожидания NodeJS может проверять, есть ли ещё невыполненые операции. Внутри NodeJS есть список запущенных, но ещё не законченных операций. NodeJS устроена так, что обходит этот список снова и снова пока какая-нибудь операция не завершится. По завершении, она считается обработанной и все колбэки, которые были завязаны на её окончание будут вызваны.

Иллюстрация сказанного через псевдокод:

```js
function addOne(thenRunThisFunction) {
  // ждем пару минут, пока выполнится операция
  waitAMinuteAsync(function waitedAMinute() {
    // по завершении операции вызываем коллбек-функцию
    thenRunThisFunction();
  });
}

// передаем в addOne коллбек-функцию
addOne(function thisGetsRunAfterAddOneFinishes() {});
```

Представьте, что у вас есть три асинхронные функции `a`, `b` и `c`. Каждой из них на выполнение нужна минута, после чего она передает управление своему колбэку (первый аргумент). Если вам понадобится вызвать их последовательно сначала `a`, потом `b`, потом `c`, можно написать так:

```js
a(function() {
  b(function() {
    c();
  });
});
```

Когда код начнет выполняться:
1. `a` стартует сразу;
2. затем через минуту `a` закончит выполнение и вызовется `b`;
3. затем ещё через минуту `b` закончит выполнение и вызовется `c`;
4. и наконец спустя 3 минуты после старта, NodeJS остановится, потому что выполнять будет нечего.
 
Есть и другие более выразительные способы чтобы описать приведенный пример, но суть в том, что если у вас есть код, который должен выполниться по окончании другого асинхронного кода, то вам нужно показать эту зависимость, поместив свой код в фукнцию и потом передать её как колбэк.

Такой способ построения программ требует не-линейного мышления. Рассмотрим список операций:

```
прочитать файл
обработать этот файл
```

Если перевести их в псевдокод, то мы получим:

```
const file = readFile();
processFile(file);
```

Такой тип линейного (последовательного, шаг-за-шагом) построения программ не работает в NodeJS. Если код начнет выполняться в таком виде, то `readFile` и `processFile` будут выполняться одновременно. И `processFile` не получит подготовленную переменную `file`. Поэтому вам надо указать, что `processFile` должен дождаться окончания работы `readFile`. И это как раз то, для чего и нужны колбэки! А благодаря возможностям JS вы можете описывать такие зависимости разными способами:

```js
const fs = require('fs');
fs.readFile('movie.mp4', finishedReading);

function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с movieData
}
```

Вы можете написать код по-другому и он тоже сработает:

```js
const fs = require('fs');

function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с movieData
}

fs.readFile('movie.mp4', finishedReading);
```

Или даже так:

```js
const fs = require('fs');

fs.readFile('movie.mp4', function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с movieData
})
```

### События

> События (Events) они же ивенты - одно и то же, просто термины употребляются разными людьми в разных контекстах по-своему. Поэтому призываю не привязываться к словам, а зреть в корень. - прим. перев.

В NodeJS, если вам нужен модуль [events](https://nodejs.org/api/events.html), то можно использовать **генератор событий** (event emitter), который используется самой NodeJS для своих API.

События - важный паттерн в программировании, более известный как [Наблюдатель](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) или издатель / подписчик (publish / subscribe). Как мы увидели, колбэки реализуют модель отношений один-к-одному между колбэком и тем, кто его вызывает, события же реализуют тот же паттерн, но для другого типа отношений - многие-ко-многим (many-to-many).

Принципы работы событий проще представить, как подписку на уведомление, они позволяют вам _подписаться_ на уведомление о выполнении какого-то действия и вы получите гарантированное уведомление о выполнении этого действия. Вы можете сказать "когда произойдет X сделать Y", в то время как простые колбэки понимаю только "сделай X потом сделай Y". По итогу подход событий более универсальный чем подход колбэков.

Несколько примеров, где события смогли бы заменить колбэки:

- Чат, где можно оповещать разных слушателей (listeners) о новых сообщениях;
- Игровой сервер, которому нужно знать когда игроки подключились, отключились, переместились, ударили, прыгнули и т.п. (совершили игровые действия);
- Игровой движок, где можно позволить разработчикам подписываться на события. Примерно так: `.on('jump', function() {})`;
- Низкоуровневый веб-сервер, для которого нужен открытый API, чтобы перехватывать события, например так `.on('incomingRequest')` или так `.on('serverError')`.

Если попробовать написать модуль, который подключается к чат-серверу используя только колбэки, то это будет выглядеть примерно так:

```js
const chatClient = require('my-chat-client');

function onConnect() {
   // показываем пользователю, что мы подключились
}

function onConnectionError(error) {
   // показываем ошибку пользователю
}

function onDisconnect() {
  // говорим пользователю, что он отключился
}

function onMessage(message) {
  // показываем сообщение в ui чата
}

chatClient.connect(
  'http://mychatserver.com',
  onConnect,
  onConnectionError,
  onDisconnect,
  onMessage
)
```

Выглядит довольно неуклюже, поскольку все функции для вызова `.connect` надо передавать в одном месте и в определенном порядке. Напишем то же самое, но с помощью событий:

```js
const chatClient = require('my-chat-client').connect();

chatClient.on('connect', function() {
  // показываем пользователю, что мы подключились
});

chatClient.on('connectionError', function() {
  // показываем ошибку пользователю
})

chatClient.on('disconnect', function() {
  // говорим пользователю, что он отключился
})

chatClient.on('message', function() {
  // показываем сообщение в ui чата
})
```

Похоже на вариант с чистыми колбэками, но вводится новый метод `.on`, который и *подписывает* функцию-колбэк на определенный тип событий. Это значит, что вы можете выбирать на какие события подписаться из `chatClient`. Можно даже подписать на одно событие несколько разных колбэков:

```js
const chatClient = require('my-chat-client').connect();
chatClient.on('message', logMessage);
chatClient.on('message', storeMessage);

function logMessage(message) {
  console.log(message);
}

function storeMessage(message) {
  myDatabase.save(message);
}
```

### Потоки

На ранних стадиях развития NodeJS внутри API для работы с файловой системой и сетью использовались внутренние приемы работы с потоками ввода/вывода. Например, для файлов применялись так называемые файловые дескрипторы, соответственно, модуль `fs` был наделён дополнительной логикой, позволяющей их отслеживать, в то время, как для сетевых модулей такая концепция не использовалась. Несмотря на незначительные отличия в семантиках, на самом низком уровне, где надо было считывать и записывать данные кодовые базы этих API во многом повтряли друг друга.
Команда, работающая над NodeJS, осознала, что такое положение дел будет только путать разработчиков, которым придется изучать две группы семантик, чтобы сделать по сути одно и тоже. Они сделали новый API, который назвали `Потоком` (`Stream`) и переписали весь код для работы с ФС и сетью уже на нем. Главная задача NodeJS - сделать работу с ФС и с сетями простой и удобной, поэтому было разумно иметь единый общий подход, который использовался бы повсюду. Главный плюс заключается в том, что большинство паттернов на данный момент уже реализованы и маловероятно, что NodeJS в будущем сиьно изменится.

Есть 2 отличных ресурса, которые можно использовать для изучения потоков в NodeJS. Первый - stream-adventure (см. раздел "Изучите NodeJS интерактивно") и другой - справочник, называемый Stream Handbook.

#### Stream Handbook

[stream-handbook](https://github.com/substack/stream-handbook#introduction) - гайд, похожий на этот, в котором есть ссылки на всё, что только может понадобиться при изучении потоков.

[![stream-handbook](https://user-images.githubusercontent.com/4215285/71122313-5380b400-21f1-11ea-9bff-4efbe3b384f2.png)](https://github.com/substack/stream-handbook)

### Модули и npm - экосистема NodeJS

Ядро NodeJS включает в себя более 20 модулей, которые делятся на низкоуровневые, такие как `events` и `stream`, и высокоуровневые типа `http` and `crypto`.

Такая структура выбрана неслучайно. Ядро изначально предполагалось сделать небольшим и независмым от платформы, а главная задача модулей - обеспечивать работу с основными I/O протоколами и форматами.

Для всего остального есть пакетный менеджер Node - [npm](https://www.npmjs.com/). Каждый может создать модуль и опубликовать его для npm. На момент написания этих строк на npm было около 34 тысячи модулей.

#### Как найти нужный модуль

Представьте, вам надо сконвертировать PDF файлы в текстовые. Начать стоит с команды `npm search pdf`:

![pdfsearch](https://user-images.githubusercontent.com/4215285/71122322-57143b00-21f1-11ea-8a96-a432b1dcd2d9.png)

Он выдаст кучу результатов. npm очень популярен и вы наверняка сможете найти здесь подходящее решение для своей задачи. Если внимательно рассматривать каждый модуль и фильтровать результаты поисков (убирая, например, модули PDF-генераторов), то в конце концов получится список:

- [hummus](https://github.com/galkahana/HummusJS/wiki/Features) - c++ pdf manipulator
- [mimeograph](https://github.com/steelThread/mimeograph) - api on a conglomeration of tools (poppler, tesseract, imagemagick etc)
- [pdftotextjs](https://www.npmjs.com/package/pdftotextjs) - wrapper around [pdftotext](https://en.wikipedia.org/wiki/Pdftotext)
- [pdf-text-extract](https://www.npmjs.com/package/pdf-text-extract) - another wrapper around pdftotext
- [pdf-extract](https://www.npmjs.com/package/pdf-extract) - wrapper around pdftotext, pdftk, tesseract, ghostscript
- [pdfutils](https://www.npmjs.com/package/pdfutils) - poppler wrapper
- [scissors](https://www.npmjs.com/package/scissors) - pdftk, ghostscript wrapper w/ high level api
- [textract](https://www.npmjs.com/package/textract) - pdftotext wrapper
- [pdfiijs](https://github.com/fagbokforlaget/pdfiijs) - pdf to inverted index using textiijs and poppler
- [pdf2json](https://github.com/modesty/pdf2json/blob/master/readme.md) - pure js pdf to json

Есть много модулей, которые повторяют функционал друг друга, но предоставляют разные API и многие требуют установки внешних зависимостей (например, `apt-get install poppler`).

Несколько примеров, на что стоит обращать внимание при выборе нужного модуля:

- `pdf2json` единственный модуль, написанный на чистом js и скорее всего это значит, что он прост в установке. Особенно на маломощных устройствах типа raspberry pi или на Windows, у которого нативный код не может быть перенесен на другую платформу;
- модули типа `mimeograph`, `hummus` и `pdf-extract` объединяют в себе несколько низкоуровневых модулей, чтобы предоставить к ним высокоуровневый API;
- много модулей используют под собой никсовские тулзы `pdftotext`/`poppler`.

Давайте сравним `pdftotextjs` и `pdf-text-extract`, оба являются лишь оболочками вокруг утилиты `pdftotext`.

![pdf-modules](https://user-images.githubusercontent.com/4215285/71122527-dbff5480-21f1-11ea-9802-819dfb261b6f.png)

Сходства:

- обновлены относительно недавно;
- имеют свои репозитории на гитхабе (что очень важно);
- имеют README файлы;
- каждую неделю скачиваются пользователями;
- имеют открытую лицензией (т.е. может воспользоваться любой).

По данным `package.json` и статистике модуля сделать правильный выбор совсем непросто. Давайте сравним файлы описаний README:

![pdf-readmes](https://user-images.githubusercontent.com/4215285/71122533-defa4500-21f1-11ea-9b5d-71c8370e98cb.png)

Оба имеют простые понятные описания, значки CI, инструкции по установке, примеры использования, инструкции по запуску тестов. Отлично! Но какой же выбрать? Сравним код внутри:

![pdf-code](https://user-images.githubusercontent.com/4215285/71122619-19fc7880-21f2-11ea-9814-f376f8cc2320.png)

В `pdftotextjs` примерно 110 строк кода, а в `pdf-text-extract` около 40, но у обоих всё сводится по сути к одной строке:

```js
var child = shell.exec('pdftotext ' + self.options.additional.join(' '));
```

Делает ли это одну лучше другой? Трудно сказать! Здесь важно самому прочитать код и сделать свои выводы. Если найдете модуль, который вам понравится, наберите `npm star modulename`. Так можно сказать npm, что вам понравилось пользоваться этим модулем.

#### Модульный подход к разработке

npm отличается от большинства пакетных менеджеров тем, что устанавливает модули в папку внутри других существующих модулей. Это может быть непонятно сразу, но это чуть ли не ключевой фактор успеха npm.

Многие пакетные менеджеры (далее ПМ) устанавливают их глобально (т.е. к пакету можно обратиться прямо из консоли любой директории). Например, Если набрать `apt-get install couchdb` на Debian Linux - он поставит последнюю стабильную версию CouchDB. Теперь, если вы попытаетесь установить программу, у которой есть зависимость от более старой версии CouchDB, то вам придется удалить свежую версию CouchDB и только после этого поставить более старую. У вас не получится поставить две версии CouchDB, потому что Debian устанавливает все пакеты в одно место.

Это относится не только к Debian. Многие ПМы языков программирования работают по тому же принципу. Чтобы избежать описанного выше конфликта зависимостей, было разработано виртуальное окружение (virtual environment), похожее на [virtualenv](http://python-guide.readthedocs.org/en/latest/dev/virtualenvs/) у Python или [bundler](http://bundler.io/) из мира Ruby. Они разбивают привычное окружение на множество виртуальных, по одному на каждый проект, но внутри каждое такое окружение ставит пакеты всё так же глобально для этого виртуального. Такие виртуальные окружения не всегда решают проблему, иногда они только раздувают её, создавая новые уровни сложности.

Для npm установка глобальных модулей - антипаттерн (плохой подход). 

Также как в программах на JS вы не станете использовать глобальные переменные, вы также не станете устанавливать модули глобально (пока вам не понадобится модуль с исполняемым файлом, чтобы обратиться к нему в глобальном `PATH`, но такая ситуация будет возникать редко).

##### Как работает команда `require`

Когда вы используете `require('some_module')` в NodeJS, вот что происходит:

1. Если вызываемый файл `some_module.js` существует в текущей папке, то NodeJS подгрузит его;
2. Иначе NodeJS будет искать в текущей папке папку с именем `node_modules` и внутри неё папку с именем `some_module`;
3. Если она её и там не найдет, то NodeJS поднимется на 1 уровень вверх и повторит шаг 2.

Этот цикл повторяется пока NodeJS не доберется до корневой папки ФС, оттуда она проверит все папки глобальных модулей (такие как `/usr/local/node_modules` на Mac OS) и, если так и не встретит `some_module`, то выбросит исключение.

Рассмотрим пример такого поиска:

![mod-diagram-01](https://user-images.githubusercontent.com/4215285/71125957-00aafa80-21f9-11ea-8ace-24f24e9bd556.jpg)

Находясь в папке `subsubfolder` и вызвав `require('foo')`, NodeJS будет искать папку `subsubfolder/node_modules`. Здесь она его не найдет - папка здесь нарочно называется `my_modules`. Тогда NodeJS поднимется вверх на 1 уровень и попробует искать снова в данном случае папку `subfolder_B/node_modules`, которой также не существует. Третья попытка окажется удачной - папка `folder/node_modules` существует *и* имеет внутри себя папку `foo`. Если бы `foo` и здесь не было - NodeJS продолжила бы поиск в родительской директории.

Отметим, что если бы NodeJS была вызвана из `subfolder_B`, то она бы никогда не попала в папку `subfolder_A/node_modules`. Поднимаясь вверх по дереву папок она сможет попасть только в `folder/node_modules`.

Одно из преимуществ подхода npm в том, что модули сами могут устанавливать свои зависимости, причем тех версий, которые актуальны для них самих. В нашем примере, модуль `foo` оказался крайне популярен - 3 копии пакета, по одному на каждую родительскую папку самого модуля. Причиной этому можеть быть то, что каждый родительский модуль нуждается в своей версии пакета `foo`, т.е. `folder` нужен `foo@0.0.1`, `subfolder_A` нужен `foo@0.2.1` и т.д.

Посмотрим, что произойдет когда мы исправим ошибку имени директории, сменив его с `my_modules` на правильное `node_modules`:

![mod-diagram-02](https://user-images.githubusercontent.com/4215285/71125959-00aafa80-21f9-11ea-9fdc-87e634c0f030.jpg)

Чтобы протестить какой модуль фактически загружен NodeJS, вы можете вызвать команду `require.resolve('some_module')`, которая выведет путь к тому модулю, который NodeJS нашла при обходе директорий. `require.resolve` может оказаться полезной когда вам надо убедиться в том, что загружен именно тот модуль и той версии, которую вы ожидаете. Бывает, что версия подключенного модуля отличается от той, которую мы ожидаем увидеть, - это значит, что NodeJS нашла такой модуль быстрее, чем тот, который нам нужен.

#### Как написать свой модуль

Теперь, когда мы узнали как искать модули и как подключать их в программу вы можете начать писать свои.

##### Самый простой из возможных модулей

Модули NodeJS крайне легковесны. Один из самых простых модулей выглядит так:

`package.json`:
```js
{
  "name": "number-one",
  "version": "1.0.0"
}
```

`index.js`:
```js
module.exports = 1;
```

По умолчанию, когда вы вызываете `require('module')`, NodeJS пробует загрузить `module/index.js`. С любым другим именем файла это не сработает, пока вы не укажете его явно в файле `package.json` в поле `main`.

Положите оба этих файла в папку `number-one` (значение `name` в `package.json` должно совпадать с именем папки) и вы получите готовый рабочий модуль.

Вызывая функцию `require('number-one')` вы получите то значение, которое установлено для `module.exports` внутри модуля.

![simple-module](https://user-images.githubusercontent.com/4215285/71123493-d7d43680-21f3-11ea-9b39-8a09312ca7f0.png)

Для создания модуля есть ещё способ, даже более быстрый. Выполните эти команды:

```sh
mkdir my_module
cd my_module
git init
git remote add git@github.com:yourusername/my_module.git
npm init
```

Выполнив в консоли `npm init` создастся валидный `package.json` и, если запустить его в существующем `git` репозитории, то он автоматом проставит поле `repositories` внутри `package.json`.

##### Добавляем зависимости

У модуля может быть список других модулей из npm или GitHub в поле `dependencies` в файле `package.json`. Чтобы установить модуль `request`, как новую зависимость и сразу доавбить его в `package.json`, выполните следующую команду в корневой папке модуля:

```sh
npm install --save request
```

Этим вы устанавливаете копию `request` в закрытую папку `node_modules`, и наш `package.json` будет похож на этот:

```
{
  "id": "number-one",
  "version": "1.0.0",
  "dependencies": {
    "request": "~2.22.0"
  }
}
```

По умолчанию, `npm install` подтягивает последнюю опубликованную версию модуля.

### Разработка клиентской части с npm

Основное заблуждение о npm - то, что если в названии встречается слово Node.js, то это будет использоваться только на сервере. Совсем нет. npm  - менеджер пакетов NodeJS, он отвечает за те модули, которые NodeJS упаковывает. Сами же модули могут быть чем угодно -- это просто папка с файлами, собранная в архив и файлом `package.json`, который описывает версию модуля и список своих зависимостей (вместе с версиями тех модулей, от которых он сам зависит, так что рабочие версии всех модулей поставятся автоматически). Эта цепочка очень длинная - модуль зависят от других модлуей, которые в свою очередь зависят от других и т.д.

Утилита [browserify](http://browserify.org/), написанная на NodeJS, конвертирует модуль NodeJS так, чтобы его код можно было выполнять в браузере. Не со всеми модулями такое получится сделать (браузер, например, не может выступать в качестве HTTP-сервера).

Чтобы попробовать возмоности npm в браузере используйте модуль [RequireBin](http://requirebin.com/), это приложение, которое я сделал, вобрало в себя плюсы [Browserify-CDN](https://github.com/jfhbrook/wzrd.in), который сам внутри использует browserify, но результат выдает через HTTP (а не на консоль, как это делает browserify).

Скопируем этот код в окно RequireBin нажмем "Run Code":

```js
const reverse = require('ascii-art-reverse');

// делаем доступной html-консоль
require('console-log').show(true);

const coolbear =
  "    ('-^-/')  \n" +
  "    `o__o' ]  \n" +
  "    (_Y_) _/  \n" +
  "  _..`--'-.`, \n" +
  " (__)_,--(__) \n" +
  "     7:   ; 1 \n" +
  "   _/,`-.-' : \n" +
  "  (_,)-~~(_,) \n";

setInterval(function() { 
    console.log(coolbear);
}, 1000);

setTimeout(function() {
  setInterval(function() { 
    console.log(reverse(coolbear));
  }, 1000);
}, 500);
```

[Или другой пример](http://requirebin.com/?gist=679b58d4237eaca37173) (смело меняйте код, чтобы увидеть что будет):

[![requirebin](https://user-images.githubusercontent.com/4215285/71123757-6943a880-21f4-11ea-81ed-271ad956cd12.png)](http://requirebin.com/embed?gist=679b58d4237eaca37173)

### Правильный выбор инструмента

Как любой хороший инструмент, NodeJS как никто лучше справляется с тем кругом задач, для решения которых она была сделана. К примеру, фреймворк Rails отлично подходит для построения сложной [бизнес-логики](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0), где код используется для представления реальных бизнес-объектов. И хотя чисто технически такая задача NodeJS под силу, но, решая её, у вас возникнут проблемы, потому что NodeJS создавалась для решения задач ввода/вывода, а не для написания бизнес-логики. Каждый инструмент создается под свои задачи. Надеюсь, этот гайд поможет вам понять и прочувствовать сильные стороны NodeJS, чтобы у вас выработалось понимание того, в каких случаях она будет вам полезна.

### Чем не является NodeJS?

Приципиально, NodeJS - лишь инструмент для управления потоками ввода/вывода в ФС и сетях, сама NodeJS не затрагивает возможности других частей системы. Это делают уже сторонние модули. Здесь описаны несколько вещей которые ошибочно приписывают NodeJS.

#### Веб-фреймворки

Существуют фреймворки, построенные на NodeJS (фреймворк здесь понимается, как пакет для решения какой-то высоскоуровневой задачи, например моделирование бизнес-логики), но сама NodeJS не веб-фреймворк.
Веб-фреймворки, написанные на NodeJS не всегда соблюдают те принципы и правила, которые закладывались в архитектуру NodeJS.

#### Синтаксис языка

NodeJS использует JS и не собирается что-то менять. У Felix Geisendörfer есть отличное описание своего видения стиля NodeJS [here](https://github.com/felixge/node-style-guide).

#### Языковые абстракции

Всегда когда это возможно, NodeJS будет использовать самый простой способ для выполнения задачи, перед которой её поставили. Пограммирование вещь непростая, особенно в JS, где на каждую проблему найдется 1000 возможных решений! Эта та причина, по которой NodeJS старается всегда находить самое простое и универсальное решение. Но если вы сталкиваетесь с задачей, которая приводит к запутанному решению, и вам не нравятся те готовые решения, которые предлагает NodeJS, вы в праве самостоятельно решить её в своем приложении - выбрать модуль, который понравится, или абстракции которые подойдут.

Хорошей иллюстрацией этих слов служит использование колбэков. В ранних версиях NodeJS был популярен прием с использованием промисов, которые позволяли писать асинхронный код так, он выглядел как линейный. Но в тот момент (сейчас она присутствует) эту фичу исключили из ядра NodeJS по нескольки причинам:

- промисы гораздо сложнее в использовании чем колбэки;
- их можно использовать, установив специальный модуль.

Рассмотрим пример с чтением файла. Когда вы читаете файл, необходимо знать, какие ошибки произошли (например, отказал жесткий диск прямо во время чтения файла). Если бы NodeJS использовала промисы, то приходилось бы ветвить свой код, как здесь:

```js
fs.readFile('movie.mp4')
  .then(function(data) {
    // сделать что-то с data
  })
  .error(function(error) {
    // обработать ошибку
  });
```

Это добавляет ненужную сложность, что понравится не каждому. Вместо двух отдельных функций в NodeJS используется единая колбэк-функция. Для неё действуют правила:

- Когда ошибки нет, первым аргументом идет null;
- Когда ошибка есть, передаем её первым аргументом;
- Остальные аргументы могут использованы как угодно (обычно, это будут данные или ответы на запросы, ведь NodeJS по большей части работает с вводом / выводом).

Отсюда такой стиль написания колбэков:

```js
fs.readFile('movie.mp4', function(err, data) {
  // обрабатываем ошибку err и делаем какие-то действия с data
})
```

#### Threads / Fibers / Non-event-based Concurrency Solutions

Замечание: если вы ещё не сталкивались с этими терминами, возможно, вам будет проще освоить NodeJS.

Чтобы делать всё быстро NodeJS использует внутри себя потоки, но сама скрывает их от пользователя. Если вы технарь, и вам интересно как устроена NodeJS внутри, вам совершенно точно надо прочитать об [архитектуре библиотеки libuv](http://nikhilm.github.io/uvbook/) - C++ I/O слое, на котором держится сама NodeJS.

### Источник

Данный материал основан на [art-of-node](https://github.com/maxogden/art-of-node), созданном [Max Ogden](https://github.com/maxogden).

Спасибо за перевод Andrey Safronov и bereg_73. Сам перевод [тут](https://github.com/maxogden/art-of-node/blob/master/readme.ru.md).

Делал ревью и добавлял кучу правок [vladthelittlone](https://github.com/vladthelittleone).
