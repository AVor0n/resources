## Поэзия Ноды

> Данный перевод на доработке. В ближайшее время он будет исправляться и актуализироваться.
> 
> Данная статья немного устарела, но все-равно позволит вам прояснить некоторые вопросы.

Итак, вы разобрали основы NodeJS. В статье мы еще раз пройдемся по всем основным моментам связанным с данной технологией.

### Изучи Ноду интерактивно

В дополнение к чтению, очень важно параллельно писать код. Так вы скорее проникнетесь духом ноды и вникнете в её суть. Читать код в книге важно и нужно, но обучение через само написание кода - это ещё более лучший способ познания новых принципов программирования.

### NodeSchool.io

[NodeSchool.io](http://nodeschool.io/) серия открытых интерактивных воркшопов, по которым можно обучиться основным принципам Ноды.

[Learn You The Node.js](https://github.com/workshopper/learnyounode#learn-you-the-nodejs-for-much-win) представляет собой вступительный воркшоп NodeSchool.io. Здесь собраны несколько задач, решение которых поможет вам усвоить основные принципы построения программ для Ноды. Устанваливается как консольная утилита.

[![learnyounode](https://github.com/rvagg/learnyounode/raw/master/learnyounode.png)](https://github.com/rvagg/learnyounode#learn-you-the-nodejs-for-much-win)

Устанавливается через npm:

```
# install
npm install learnyounode -g

# start the menu
learnyounode
```

## Путь к пониманию Ноды

Node.js - опенсорсный проект, сделанный чтобы помочь вам писать программы для работы с сетью, файловыми системами и другими I/O (input/output, reading/writing) на языке JavaScript. Вот и всё! Это простая и стабильная I/O платформа в которой удобно создавать свои модули.

Какие ещё есть примеры использования ввода/вывода (далее I/O)? Здесь показана схема приложения, к-ое я делал на Ноде; на ней видно какие могут быть I/O источники:

![server diagram](https://github.com/maxogden/art-of-node/raw/master/server-diagram.png)

Если вы не знаете все источники представленные на схеме, ничего страшного. Суть в том, чтобы показать, что один единственный процесс Ноды (шестигранник в центре) может выполнять роль брокера (диспетчера) между разными конечными пунктами (endpoints) I/O (оранжевым и фиолетовым обозначены каналы ввода/вывода).

Обычно, построение систем такого вида складывается по одному из путей:

- сложно для написания, но в результате получается супер-быстрая система (подобно написанию своих веб-серверов на чистом C)
- просты в написании но сильно страдает в скорости работы (особенно, когда кто-то пытается отправить на сервер 5Гб файл и твой сервер падает)

Задача Ноды - сохранить равновесие при достижении двух целей: быть достаточно простой для понимания, использования и настолько же быстрой для решения большинства задач.

Нода не является:
 - веб-фреймворком (вроде Rails или Django, хотя и может использоваться для создания подобных вещей)
 - языком программирования (Нода использует JS, но сама Нода языком НЕ является)

Нода - нечто среднее, можно сказать, что Нода:

  - Сделана чтобы быть простой для понимания и использования
  - Удобной при создании I/O программ, которые должны работать быстро и оставаться устойчивой к высоким нагрузкам
  
На более низком уровне, Ноду можно назвать инструментом для написания двух типов программ:

  - Сетевые программы, использующие протоколы веба: HTTP, TCP, UDP, DNS и SSL
  - Программы, для чтения и записи данных в файловую систему (далее ФС) или локальные процессы/память

Что означает "программы для I/O" ("I/O based program")? Рассмотрим несколько основых источников Ввода/Вывода (I/O sources):

  - Базы данных (MySQL, PostgreSQL, MongoDB, Redis, CouchDB)
  - Внешние API (Twitter, Facebook, Apple Push Notifications)
  - HTTP/WebSocket соединения (от пользователей веб-приложений)
  - Файлы (сжатие изображений, редактирование видео, интернет-радио)

Нода выполняет операции ввода/вывода способом, к-ый называют асинхронным [asynchronous](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4). Такой способ позволяет ей выполнять много разных операций одновременно (simultaneously). Приведу небольшой пример для большего понимания. Например, зайдя в какой-нибудь фаст-фуд и заказав чизбургер, ваш заказ примут *сразу*, и после *небольшой задержки* ваш заказ будет готов. Пока вы ждете, они могут принимать другие заказы и начать готовить чизбургеры для других людей. А теперь представьте ситуацию, когда остальным людям в очереди приходится ждать пока вам не принесут чизбургер. Они даже не смогут сделать заказ, пока вам его не приготовят! Технически такое поведение называется **блокирующая очередь**, ведь все операции ввода/вывода (по приготовлению чизбургеров) происходят строго по одной в 1 момент времени. Нода же, наоборот, реализует механизм **неблокирующей очереди**, что позволяет готовить много чизбургеров одновременно.

На Ноде такие вещи можно реализовать довольно легко, благодаря её неблокирующей сущности:
  
  - Механизм управления [летающими квадракоптерами](http://www.nodecopter.com/)
  - Написать IRC чат-ботов
  - Создать [ходячих роботов](https://www.youtube.com/watch?v=jf-cEB3U2UQ)

## Базовые модули (Core modules)

Во-первых, установите Ноду себе на компьютер. Брать её лучше отсюда [nodejs.org](http://nodejs.org).

У ноды есть небольшая группа базовых модулей (которую обычно называют одним термином 'Ядро Ноды' ('node core')), которые предоставлены, как внешний API для написания программ. Каждый модуль предназначен для своих целей: для работы с файловой системой есть модуль `fs`, для работы с сетями `net` (TCP), `http`, `dgram` (UDP).

Помимо модуля `fs` и сетевых модулей, есть и другие базовые модули. Для асинхронной работы с DNS-запросами есть модуль `dns`, `os` - для получения данных об ОСи, для выделения бинарных фрагентов памяти есть `buffer`, модули для различного рода парсинга урлов, путей к файлам (`url`, `querystring`, `path`). Большинство из базовых модулей, если не все, служат для одной общей цели - написание быстрых (!) программ для работы с файловой системой или сетью.

Нода обрабатывает I/O-операции используя: колбэки, события, потоки и модули. Если вы знаете как они работают, то сможешь разобраться в любом базовом модуле и понять как его правильно использовать.

## Колбэки (Callbacks)

Это, пожалуй, самая важная часть всего гайда. Если хочешь понять как работает Нода - придется разобраться с колбэками. Колбэки используются в Ноде повсюду; это не открытие Ноды, они лишь часть языка JavaScript.

Итак, начнем с определения. Колбэки - функции, которые вызываются не сразу, по мере выполнения основного кода, а асинхронно (asynchronously), т.е. их *выполнение* (invoking) будет отложено. В отличие от привычного процедурного стиля написания и выполнения кода **сверху вниз** (top to bottom), асинхронные программы могут выполнять свои функции непоследовательно (не в порядке их написания), учитывая скорость выполнения предыдущих функций, например http-запросов или чтения с диска.

Поначалу такое отличие попросту сбивает с толку. Действительно, бывает трудно определить заранее, будет ли функция выполняться асинхронно или нет - во многом это зависит от контекста её выполнения. Разберем простой пример синхронного выполнения, где код будет выполняться последовательно сверху вниз:

```js
let myNumber = 1;
function addOne() { myNumber++; } // определяем функцию
addOne(); // выполняем функцию
console.log(myNumber); // 2
```

В коде определяется функция и на след строке происходит её вызов, без задержек и пауз. Когда функция вызывается, myNumber *сразу* увеличится на 1. Мы уверены, что после вызова функции число станет равным 2. Это и есть предсказуемость синхронного кода - он всегда выполняется последовательно сверху вниз.

Нода же часто использует асинхронную модель выполнения кода. Давайте с помощью Ноды прочитаем число из файла `number.txt` (файл находится на диске, а значит будем использовать модуль `fs` - прим. перев.):

```js
const fs = require('fs'); // подключение модуля для работы с ФС
let myNumber = undefined; // пока мы не знаем какое число записано в файле

function addOne() {
  fs.readFile('number.txt', function doneReading(err, fileContents) {
    myNumber = parseInt(fileContents);
    myNumber++;
  });
}

addOne();

console.log(myNumber); // undefined -- эта строка выполнится до того, как будет прочитан файл!
```

Почему же после вызова функции мы получили `undefined`? Обратите внимание, в коде мы используем асинхронный метод `fs.readFile`. Обычно, такие функции, где идут операции чтения-записи на диск или работа с сетью, делают асинхронными. Когда же требуется обратиться к памяти напрямую или поиспользовать возможности процессора, то функции делают синхронными. Дело в том, что операции I/O невероятно медленные (это относится не только к Ноде но и ко всем языкам и технологиям - прим. перев). Стоит сказать, что чтение с диска (hard drive) происходит медленнее чем из памяти (RAM) примерно в 100k раз.

Когда мы запустим эту программу, определение функций произойдет немедленно, но такая быстрота не относится к скорости их выполнения. Это ключевой принцип для понимания асинхронного программирования. Когда произойдет вызов `addOne` она следом запустит функцию `readFile`, но не будет ждать окончания её работы, а перейдет к следующей задаче. Если Ноде больше нечего выполнять она будет просто ждать окончания IO-операций чтобы закончить работу и выйти.

Далее, когда `readFile` прочитает файл (это может занять некоторое время от нескольких миллисекунд до нескольких секунд или даже минут, в зависимости от того как быстро происходит чтение с диска), следом будет выполняться функция `doneReading`, которая и выдаст содержимое файла (если чтение прошло успешно) или ошибку.

В нашей программе мы получили на выходе `undefined`, потому что в нашем коде нет никаких явных указаний функции `console.log` дождаться окончания выполнения `readFile` перед тем как выводить число.

Если вы хотите, чтобы какой-то код гарантированно выполнился последовательно, сперва поместите этот код в функцию! Только после этого вы сможете вызвать функцию (выполнить блок кода) там, где необходимо. Это должно подтолкнуть вас давать функциям точные и понятные имена.

Важно запомнить, что колбэки - просто функции, но которые выполнятся не сразу, по мере чтения кода, а тогда, когда произойдет определенное событие. Ключ к пониманию механизма коллбэков лежит в том, что ты никогда не узнаешь, *когда* (в какой момент времени) закончится асинхронная операция (I/O), но ты будешь уверен в том, **где** (после какого события) операция закончится - на последней строке асинхронной функции (т.е. колбэка)! Порядок объявления колбэков не имеет никакого значения и не влияет на последовательность выполнения. Значение имеет только их логическая вложенность, иерархичность если хотите. Сперва ты разбиваешь свой код на функции (как обособленные части кода) и только потом используешь колбэки, чтобы описать зависмости между их вызовами.

Снова вернемся к программе. Метод `fs.readFile`, предлагаемый Нодой, выполняется асинхронно и требует много времени для своего выполнения. Рассмотрим происходящее детально: для выполнения функции требуется обратиться к ОСи, которой надо обратиться к ФС, которая живет на диске, который совершает тысячи оборотов в минуту. Диску надо задействовать магнитную головку (а это уже физический уровень, между прочим) чтобы прочитать данные и отправить их обратно по всем уровням нашей программе. Вы передаете методу `readFile` функцию-колбэк, которая и будет вызвана после того как данные от ФС будут получены. Колбэк поместит полученные данные в переменную и только теперь вызовет вашу функцию-коллбэк уже с имеющей значение переменной (не `undefined`). В этом случае переменная называется `fileContents`, т.к. в ней лежит содержимое всего файла.

Вспомните пример с заказом и очередью из 1 части. Во многих ресторанах вам ставят на стол номер, пока вы ждете свой заказ. Это очень похоже на коллбэк. Эти номера говорят официантам, что нужно сделать когда ваш заказ будет готов.

Вернемся к нашему примеру и вынесем выражение `console.log` в отдельную функциию и передадим её как коллбэк:

```js
const fs = require('fs');
let myNumber = undefined;

function addOne(callback) {
  fs.readFile('number.txt', function doneReading(err, fileContents) {
    myNumber = parseInt(fileContents);
    myNumber++;
    callback();
  });
}

function logMyNumber() {
  console.log(myNumber);
}

addOne(logMyNumber);
```

Теперь функцию `logMyNumber` можно передать как аргумент, который станет "колбэчной" переменной уже внутри функции `addOne`. После окончания выполнения `readFile` будет вызвана переменная `callback` (именно вызвана как функция: `callback()`). Вызываться могут только фукнции, так что если передать туда что-то другое, то это приведет к ошибке.

В JS когда функция вызывается внутри другой функции (как `callback()`), то она будет выполнена сразу. В таком контексте выражение `console.log` выполнится как `callback`-параметр, который на деле есть функция `logMyNumber`. Запонмите важную вещь, когда вы *определяете* (*define*) функцию, это ещё ничего не говорит о том, когда она будет вызвана. Чтобы она сработала надо явно произвести её вызов (*invoke*).

Чтобы окончательно закончить разбор нашего пример, выпишем все программные действия в той последовательности, в которой они выполнятся при запуске программы:

- 1: Код "спарсится", т.е. если в нем есть синтаксические ошибки, программа не запустится. В процессе "парсинга" будут определены переменные `fs` и `myNumber` и функции `addOne` и `logMyNumber`. Заметьте, что на этом этапе идут только определения. Ни одна функция пока не вызвана.
- 2: Когда выполнится последняя строка программы, будет вызвана функция `addOne` с функцией `logMyNumber` в качестве аргумента-колбэка. Вызове `addOne` приведет к запуску асинхронную функцию `fs.readFile`. Этой части программы нужно время, чтобы завершиться.
- 3: Сейчас Нода будет бездействовать и ждать пока выполнится функция `readFile`. Если бы у неё были ещё какие-то задачи - она занялась бы ими.
- 4: Как только `readFile` заканчивает работу, в дело вступает колбэк-функция `doneReading`, которая парсит `fileContents` в поиске целого числа. Результат `parseInt` присваивается `myNumber`-у, потом увеличивает его (`myNumber`) значение на 1 и затем сразу вызывается функция `addOne`, переданная как параметр `callback` в `logMyNumber`.

Пожалуй, самая непривычная часть программирования с колбэками - то как функции подобно объектам могут храниться в переменных и передаваться под разными именами. Давать простые и образные имена своим переменным - очень важное умение для программиста, особенно когда он пишет код, который будут читать другие люди. Читая Нода-программы, если вы видите переменную с именем `callback` или `cb` - скорее всего здесь ожидается функция-колбэк.

Вы наверняка слышали такие понятия, как событийно-ориентированное программирование или "ивент луп" (event loop) (если встретите где-нибудь понятие "событийный цикл" - знайте, это одно и то же. - прим. перев.). Они обозначают тот самый способ, которым реализован `readFile`. Сначала Нода отправляет на выполнение метод `readFile`, потом ждет, пока тот отправит ей "ивент" о своем окончании. В процессе ожидания Нода может проверять, есть ли ещё невыполненые операции. Внутри Ноды есть список запущенных, но ещё не законченных операций; Нода устроена так, что обходит этот список снова и снова пока какая-нибудь операция не завершится. По завершении, она считается обработанной (get 'processed') и все колбэки, которые были завязаны на её окончание будут вызваны.

Иллюстрация сказанного через псевдокод:

```js
function addOne(thenRunThisFunction) {
  waitAMinuteAsync(function waitedAMinute() {
    thenRunThisFunction();
  });
}

addOne(function thisGetsRunAfterAddOneFinishes() {});
```

Представьте, что у вас есть 3 асинхронные функции `a`, `b` и `c`. Каждой из них на выполнение надо 1 минуту, после чего она передает управление своему колбэку (её первый аргумент). Если вам понадобится вызвать их последовательно сначала `a`, потом `b`, потом `c`, можно написать так:

```js
a(function() {
  b(function() {
    c();
  });
});
```

Когда код начнет выполняться, `a` стартует сразу, затем через минуту она закончит выполнение и вызовется `b`, затем, ещё через минуту она закончит и вызовется `c` и наконец спустя 3 минуты, Нода остановится, потому что выполнять будет нечего. Есть и другие более выразительные способы чтобы описать приведенный пример, но суть в том, что если у вас есть код, который должен выполниться по окончании другого асинхронного кода, то вам нужно показать эту зависимость, поместив свой код в фукнцию и потом передать её как колбэк.

Такой способ построения программ требует не-линейного мышления. Рассмотрим список операций:

```
прочитать файл
обработать этот файл
```

Если перевести их в псевдокод, то мы получим:

```
const file = readFile();
processFile(file);
```

Такой тип линейного (последовательного, шаг-за-шагом) построения программ не работает в Ноде. Если код начнет выполняться в таком виде, то `readFile` и `processFile` будут выполняться одновременно. Так мы не сделаем зависимость на окончание выполнения `readFile`. Вместо этого, вам надо указать что `processFile` должен дождаться окончания работы `readFile`. И это как раз то, для чего и нужны колбэки! А благодаря возможностям JS вы можете описывать такие зависимости разными способами:

```js
const fs = require('fs');
fs.readFile('movie.mp4', finishedReading);

function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с  movieData
}
```

Но вы можете написать код по-другому и он тоже сработает:

```js
const fs = require('fs');

function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с  movieData
}

fs.readFile('movie.mp4', finishedReading);
```

Или даже так:

```js
const fs = require('fs');

fs.readFile('movie.mp4', function finishedReading(error, movieData) {
  if (error) { 
    return console.error(error);
  }
  // делаем что-нибудь с  movieData
})
```

## События*

*События (Events) они же 'ивенты' - суть одно и то же, просто термины употребляются разными людьми в разных контекстах по-своему. Поэтому призываю не привязываться к словам, а зреть в корень. - прим. перев.

В Ноде, если вам нужен модуль [events](https://nodejs.org/api/events.html) то можно использовать "генератор событий" (event emitter), который сам используется Нодой для своих API.

События - основной паттерн в программировании, более известный как ["Наблюдатель"](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) или издатель\подписчик (publish/subscribe или совсем кратко 'pub/sub'). Поскольку колбэки реализуют модель отношений один-к-одному (one-to-one) между колбэком и тем кто его вызывает, события реализуют тот же паттерн для другого типа отношений - многие-ко-многим (many-to-many).

Принципы работы событий проще понять, как некую подписку на уведомление, они позволяют вам "подписаться" на уведомление о выполнении какого-то действия и вы получите гарантированное уведомление о выполнении этого действия. Вы можете сказать "когда произойдет X сделать Y", в то время как простые колбэки понимаю только "сделай X потом сделай Y". По итогу подход событий более универсальный чем подход колбэков.

Несколько примеров использования, где события смогли бы заменить колбэки:

- Чат, где вы смогли бы оповещать разных слушателей (listeners) о новых сообщениях
- Игровой сервер, которому нужно знать когда игроки подключились, отключились, переместились, ударили, прыгнули и т.п. (совершили игровые действия)
- Игровой движок, где вы можете позволить разработчикам подписываться на события примерно так: `.on('jump', function() {})`
- Низкоуровневый веб-сервер, для которого нужен открытый API, чтобы перехватывать события, например так `.on('incomingRequest')` или так `.on('serverError')`

Если попробовать написать модуль, который подключается к чат-серверу используя только колбэки, то это будет выглядеть примерно так:

```js
const chatClient = require('my-chat-client');

function onConnect() {
   // показываем пользователю, что мы подключились
}

function onConnectionError(error) {
   // показываем ошибку пользователю
}

function onDisconnect() {
  // говорим пользователю, что он отключился
}

function onMessage(message) {
  // показываем сообщение в ui чата
}

chatClient.connect(
  'http://mychatserver.com',
  onConnect,
  onConnectionError,
  onDisconnect,
  onMessage
)
```

Выглядит довольно неуклюже, поскольку все функции для вызова `.connect` надо передавать в одном месте и в определенном порядке. Напишем то же самое, но с помощью событий:

```js
const chatClient = require('my-chat-client').connect();

chatClient.on('connect', function() {
  // показываем пользователю, что мы подключились
});

chatClient.on('connectionError', function() {
  // показываем ошибку пользователю
})

chatClient.on('disconnect', function() {
  // говорим пользователю, что он отключился
})

chatClient.on('message', function() {
  // показываем сообщение в ui чата
})
```

Похоже на вариант с чистыми колбэками, но вводится новый метод `.on`, которыйый и *подписывает* функцию-колбэк на определенный тип событий. Это значит, что вы можете выбирать на какие события подписаться из `chatClient`. Можно даже подписать на одно событие несколько разных колбэков:

```js
const chatClient = require('my-chat-client').connect();
chatClient.on('message', logMessage);
chatClient.on('message', storeMessage);

function logMessage(message) {
  console.log(message);
}

function storeMessage(message) {
  myDatabase.save(message);
}
```

## Потоки

На ранних стадиях развития Ноды внутри API для работы с ФС и сетью использовались внутренние приемы работы с потоками ввода/вывода. Например, для файлов применялись так называемые "файловые дескрипторы", соответственно, модуль `fs` был наделён дополнительной логикой, позволяющей их отслеживать, в то время, как для сетевых модулей такая концепция не использовалась. Несмотря на незначительные отличия в семантиках, на самом низком уровне, где надо было считывать и записывать данные кодовые базы этих API во многом повтряли друг друга.
Команда, работающая над Нодой, осознала, что такое положение дел будет только путать разработчиков, которым придется изучать две группы семантик, чтобы сделать по сути одно и тоже. Они сделали новый API, который назвали `Потоком` (`Stream`) и переписали весь код для работы с ФС и сетью уже на нем. Главная задача Ноды - сделать работу с ФС и с сетями простой и удобной, поэтому было разумно иметь единый общий подход, который использовался бы повсюду. Главный плюс заключается в том, что большинство паттернов на данный момент уже реализованы и маловероятно, что Нода в будущем сиьно изменится.

Есть 2 отличных ресурса, которые можно использовать для изучения потоков в Ноде. Первый - stream-adventure (см. раздел "Изучи Ноду интерактивно") и другой - справочник, называемый Stream Handbook.

### Stream Handbook

[stream-handbook](https://github.com/substack/stream-handbook#introduction) - гайд, похожий на этот, в котором есть ссылки на всё, что только может понадобиться при изучении потоков.

[![stream-handbook](https://github.com/maxogden/art-of-node/raw/master/stream-handbook.png)](https://github.com/substack/stream-handbook)

## Модули и npm. Экосистема Ноды

Ядро Ноды (Node core) включает в себя более 20 модулей, которые делятся на низкоуровневые, такие как `events` и `stream` и высокоуровневые типа `http` and `crypto`.

Такая структура выбрана неслучайно. Ядро изначально предполагалось сделать небольшим и независмым от платформы, а главная задача модулей - обеспечивать работу с основными I/O протоколами и форматами.

Для всего остального есть пакетный менеджер Node [npm](https://www.npmjs.com/). Каждый может создать модуль и опубликовать его для npm. На момент написания этих строк на npm было около 34k модулей.

### Как найти нужный модуль

Представьте, вам надо сконвертить PDF файлы в текстовые. Начать стоит с команды `npm search pdf`:

![pdfsearch](https://github.com/maxogden/art-of-node/raw/master/npm-search.png)

Он выдаст кучу результатов. npm очень популярен и вы наверняка сможете найти здесь подходящее решение для своей задачи. Если внимательно рассматривать каждый модуль и фильтровать результаты поисков (убирая, например, модули PDF-генераторов) то в конце концов получится список:

- [hummus](https://github.com/galkahana/HummusJS/wiki/Features) - c++ pdf manipulator
- [mimeograph](https://github.com/steelThread/mimeograph) - api on a conglomeration of tools (poppler, tesseract, imagemagick etc)
- [pdftotextjs](https://www.npmjs.com/package/pdftotextjs) - wrapper around [pdftotext](https://en.wikipedia.org/wiki/Pdftotext)
- [pdf-text-extract](https://www.npmjs.com/package/pdf-text-extract) - another wrapper around pdftotext
- [pdf-extract](https://www.npmjs.com/package/pdf-extract) - wrapper around pdftotext, pdftk, tesseract, ghostscript
- [pdfutils](https://www.npmjs.com/package/pdfutils) - poppler wrapper
- [scissors](https://www.npmjs.com/package/scissors) - pdftk, ghostscript wrapper w/ high level api
- [textract](https://www.npmjs.com/package/textract) - pdftotext wrapper
- [pdfiijs](https://github.com/fagbokforlaget/pdfiijs) - pdf to inverted index using textiijs and poppler
- [pdf2json](https://github.com/modesty/pdf2json/blob/master/readme.md) - pure js pdf to json


Есть много модулей, которые повторяют функционал друг друга, но предоставляют разные API и многие требует установки внешних зависимостей (как например, `apt-get install poppler`).

Несколько примеров, на что стоит обращать внимание при выборе нужного модуля:

- `pdf2json` единственный модуль, написанный на чистом js, что означает его легкость в установке, особенно на маломощных устройствах типа raspberry pi или на Windows, у которого нативный код не может быть перенесен на другую платформу
- модули типа `mimeograph`, `hummus` и `pdf-extract` объединяют в себе несколько низкоуровневых модулей чтобы предоставить к ним высокоуровневый API
- много модулей используют под собой никсовские тулзы `pdftotext`/`poppler`

Давайте сравним `pdftotextjs` и `pdf-text-extract`, оба являются лишь оболочками вокруг утилиты `pdftotext`.

![pdf-modules](https://github.com/maxogden/art-of-node/raw/master/pdf-modules.png)

Сходства:

Оба модуля:

- обновлены относительно недавно
- имеют свои репозитории на гитхабе (что очень важно)
- имеют README файлы
- каждую неделю скачиваются пользователями
- имеют открытую лицензией (т.е. может воспользоваться любой)

По данным `package.json` и одной статистике модуля сделать правильный выбор совсем непросто. Давайте сравним файлы описаний README:

![pdf-readmes](https://github.com/maxogden/art-of-node/raw/master/pdf-readmes.png)

Оба имеют простые понятные описания, значки CI, инструкции по установке, примеры использования, инструкции по запуску тестов. Отлично! Но какой же выбрать? Сравним код внутри:

![pdf-code](https://github.com/maxogden/art-of-node/raw/master/pdf-code.png)

В `pdftotextjs` примерно 110 строк кода, а в `pdf-text-extract` около 40, но у обоих всё сводится по сути к одной строке:

```
var child = shell.exec('pdftotext ' + self.options.additional.join(' '));
```

Делает ли это одну лучше другой? Трудно сказать! Здесь важно самому прочитать код и сделать свои выводы. Если найдете модуль, который вам понравится, наберите `npm star modulename`. Так можно сказать npm, что вам понравилось пользоваться этим модулем.

### Модульный подход к разработке

npm отличается от большинства пакетных менеджеров тем, что устанавливает модули в папку внутри других существующих модулей. Это может быть непонятно сразу, но это чуть ли не ключевой фактор успеха npm.

Многие пакетные менеджеры (далее ПМ) устанавливают их глобально (т.е. к пакету можно обратиться прямо из консоли любой директории). Например, Если набрать `apt-get install couchdb` на Debian Linux - он поставит последнюю стабильную версию CouchDB. Теперь, если вы установили CouchDB, как зависмость от другого пакета или программы и эта программа требует более старую версию CouchDB, то ам придется удалить свежую версию CouchDB и только после этого поставить более старую. У вас не получится поставить две версии CouchDB, потому что Debian устанавливает все пакеты в одно место.

Это относится не только к Debian. Многие ПМы языков программирования работают по тому же принципу. Чтобы избежать описанного выше конфликта зависимостей, было разработано виртуальное окружение (далее ВО) (virtual environment), похожее на [virtualenv](http://python-guide.readthedocs.org/en/latest/dev/virtualenvs/) у Python или [bundler](http://bundler.io/) из мира Ruby. Они разбивают привычное окружение на много виртуальных, по одному на каждый проект, но внутри каждое такое окружение ставит пакеты всё так же глобально для этого виртуального. Такие ВО не всегда решают проблему, иногда они только раздувают её, создавая новые уровни сложности.

Для npm установка глобальных модулей - антипаттерн (плохой подход) (anti-pattern). 

Также как в программах на JS вы не станете использовать глобальные переменные, вы также не станете устанавливать модули глобально (пока вам не понадобится модуль с исполняемым файлом чтобы обратиться к нему в глобальном `PATH`, но такая ситуация будет возникать редко).

#### Как работает команда `require`

Когда вы используете `require('some_module')` в NodeJS, вот что происходит:

1. Если вызываемый файл `some_module.js` существует в текущей папке, то Нода подгрузит его, иначе
2. Нода поищет в текущей папке папку с именем `node_modules` и внутри неё папку с именем `some_module`
3. Если она и её не найдет, то он поднимется на 1 уровень вверх и повторит шаг 2

Этот цикл повторится пока Нода не доберется до корневой папки ФС, оттуда она проверит все папки глобальных модулей (такие как `/usr/local/node_modules` on Mac OS) и, если так и не встретит `some_module`, то тогда Нода выбросит исключение.

Рассмотрим пример такого поиска:

![mod-diagram-01](https://github.com/maxogden/art-of-node/raw/master/mod-diagram-01.png)

Находясь в папке `subsubfolder` и вызвав `require('foo')`, Нода будет искать папку `subsubfolder/node_modules`. Здесь она его не найдет - папка здесь нарочно называется `my_modules`. Тогда Нода поднимется вверх на 1 уровень и попробует искать снова, - на картинке это выглядело бы как `subfolder_B/node_modules`, которой также не существует. Третья попытка окажется удачной - папка `folder/node_modules` существует *и* имеет внутри себя папку `foo`. Если бы `foo` и здесь не было - Нода продолжила бы поиск в родительской директории.

Отметим, что если бы Нода была вызвана из `subfolder_B`, то она бы никогда не попала в папку `subfolder_A/node_modules`. Поднимаясь вверх по дереву папок она сможет попасть только в `folder/node_modules`.

Одно из преимуществ подхода npm в том, что модули сами могут устанавливать свои зависимости, причем тех версий, которые актуальны для них самих. В нашем примере, модуль `foo` оказался крайне популярен - 3 копии пакета, по одному на каждую родительскую папку самого модуля. Причиной этому можеть быть то, что каждый родительский модуль нуждается в своей версии пакета `foo`, т.е. `folder`у нужен `foo@0.0.1`, `subfolder_A`у нужен `foo@0.2.1` и т.д.

Посмотрим, что произойдет когда мы исправим ошибку имени директории, сменив его с `my_modules` на правильное `node_modules`:

![mod-diagram-02](https://github.com/maxogden/art-of-node/raw/master/mod-diagram-02.png)

Чтобы протестить какой модуль фактически загружен Нодой, вы можете вызвать команду `require.resolve('some_module')`, которая выведет путь к тому модулю, который Нода нашла при обходе директорий. `require.resolve` может оказаться полезной когда вам надо убедиться в том, что загружен именно тот модуль и той версии которую вы ожидаете -- бывает что версия подключенного модуля отличается от той, которую мы ожидаем увидеть - это значит, Нода нашла такой модуль быстрее, чем тот, который нам нужен.


### Как написать свой модуль

Теперь, когда мы узнали как искать модули и как подключать их в программу вы можете начать писать свои.

#### Самый простой из возможных модулей

Модули Ноды крайне легковесны. Один из самых простых модулей выглядит так:

`package.json`:
```js
{
  "name": "number-one",
  "version": "1.0.0"
}
```

`index.js`:
```js
module.exports = 1;
```

По умолчанию, когда вы вызываете `require('module')`, Нода пробует загрузить `module/index.js`. С любым другим именем файла это не сработает, пока вы не укажете его явно в файле `package.json` в поле `main`.

Положите оба этих файла в папку `number-one` (значение `name` в `package.json` должно совпадать с именем папки) и вы получите готовый рабочий модуль.

Вызывая функцию `require('number-one')` вы получите то значение, которое установлено для `module.exports` внутри модуля.

![simple-module](https://github.com/maxogden/art-of-node/raw/master/simple-module.png)

Для создания модуля есть ещё способ, даже более быстрый. Выполните эти команды:

```sh
mkdir my_module
cd my_module
git init
git remote add git@github.com:yourusername/my_module.git
npm init
```

Выполнив в консоли `npm init` создастся валидный (valid) `package.json` и если запустить его в существующем `git` репозитории, то он автоматом проставит поле `repositories` внутри `package.json`.

#### Добавляем зависимости

У модуля может быть список других модулей из npm или GitHub в поле `dependencies` в файле `package.json`. Чтобы установить модуль `request`, как новую зависимость и сразу доавбить его в `package.json`, выполните следующую команду в корневой папке модуля:

```sh
npm install --save request
```

Этим вы устанавливаете копию `request` в закрытую извне папку `node_modules`, и наш `package.json` будет похож на этот:

```
{
  "id": "number-one",
  "version": "1.0.0",
  "dependencies": {
    "request": "~2.22.0"
  }
}
```

По умолчанию, `npm install` подтягивает последнюю опубликованную версию модуля.

## Разработка клиентской части с npm

Основное заблуждение о npm - то, что если в названии встречается слово 'Node.js', то это будет использоваться только на сервере. Совсем нет. npm  - менеджер пакетов Ноды, он отвечает за те модули, которые Нода упаковывает. Сами же модули могут быть чем угодно -- это просто папка с файлами, собранная в архив и файлом `package.json`, который описывает версию модуля и список своих зависимостей (вместе с версиями тех модулей, от которых он сам зависит, так что рабочие версии всех модулей поставятся автоматически). Эта цепочка очень длинная - модуль зависят от других модлуей, которые в свою очередь зависят от других и т.д.

Утилита [browserify](http://browserify.org/), написанная на Ноде, конвертирует Нодовский модуль так, чтобы его код можно было выполнять в браузере. Не со всеми модулями такое получится сделать (браузер, например, не может выступать в качестве HTTP сервера), но со многими модулями такое проходит.

Чтобы попробовать возмоности Npm в браузере используйте модуль [RequireBin](http://requirebin.com/), это приложение, которое я сделал, вобрало в себя плюсы [Browserify-CDN](https://github.com/jfhbrook/wzrd.in), который сам внутри использует browserify, но результат выдает через HTTP (а не на консоль, как это делает browserify).

Скопируем этот код в окно RequireBin нажмем "Run Code":

```js
const reverse = require('ascii-art-reverse');

// делаем доступной html-консоль
require('console-log').show(true);

const coolbear =
  "    ('-^-/')  \n" +
  "    `o__o' ]  \n" +
  "    (_Y_) _/  \n" +
  "  _..`--'-.`, \n" +
  " (__)_,--(__) \n" +
  "     7:   ; 1 \n" +
  "   _/,`-.-' : \n" +
  "  (_,)-~~(_,) \n";

setInterval(function() { 
    console.log(coolbear) 
}, 1000);

setTimeout(function() {
  setInterval(function() { 
    console.log(reverse(coolbear)) 
  }, 1000);
}, 500);
```

[Или другой пример](http://requirebin.com/?gist=679b58d4237eaca37173) (смело меняйте код, чтобы увидеть что будет):

[![requirebin](https://github.com/maxogden/art-of-node/raw/master/requirebin.png)](http://requirebin.com/embed?gist=679b58d4237eaca37173)

## Правильный выбор инструмента

Как любой хороший инструмент, Нода как никто лучше справляется с тем кругом задач, для решения которых она была сделана. К примеру, фреймворк Rails отлично подходит для построения сложной [бизнес-логики](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0), где код используется для представления реальных бизнес-объектов. И хотя чисто технически такая задача Ноде под силу, но, решая её, у вас возникнут проблемы, потому что Нода создавалась для решения задач ввода/вывода, а не для написания 'бизнес-логики'. Каждый инструмент создается под свои задачи. Надеюсь, этот гайд (guide) поможет вам понять и прочувствовать сильные стороны Ноды, чтобы у вас выработалось понимание того, в каких случаях она будет вам полезна.

### Чем не является Нода?

Приципиально, Нода - лишь инструмент для управления потоками ввода/вывода в ФС и сетях, сама Нода не затрагивает возможности других частей системы, это делают уже сторонние модули. Здесь описаны несколько вещей которые ошибочно приписывают Ноде:

#### Веб-фреймворки

Существуют фреймворки, построенные на Ноде (фреймворк здесь понимается как пакет для решения какой-то высоскоуровневой задачи, например моделирование бизнес-логики), но сама Нода не веб-фреймворк.
Веб-фреймворки, написанные на Ноде не всегда соблюдают те принципы и правила, которые закладывались в архитектуру Ноды.

#### Синтаксис языка

Нода использует JS и не собирается что-то менять. У Felix Geisendörfer есть отличное описание своего видения стиля Ноды [here](https://github.com/felixge/node-style-guide).

#### Языковые абстракции

Всегда когда это возможно, Нода будет использовать самый простой способ для выполнения задачи, перед которой её поставили. Пограммирование вещь непростая, особенно в JS, где на каждую проблему найдется 1000 возможных решений! Эта та причина, по которой Нода старается всегда находить самое простое и универсальное решение. Но если вы сталкиваетесь с задачей, которая приводит к запутанному решению, и вам не нравятся те готовые решения, которые предлагает Нода, вы в праве самостоятельно решить её в своем приложении - выбрать модуль, который понравится, или абстракции которые подойдут.

Хорошей иллюстрацией этих слов служит использование колбэков. В ранних версиях Ноды был популярен прием с использованием промисов, которые позволяли писать асинхронный код так, чтобы выглядел он как линейный. Но эту фичу исключили из ядра Ноды по нескольки причинам:

- они гораздо сложнее в использовании чем колбэки
- их можно использовать, установив специальный модуль

Рассмотрим пример с чтением файла. Когда ты читаешь файл, тебе надо знать, какие ошибки произошли, например, отказал жесткий диск прямо во время чтения файла. Если бы Нода использовала промисы, то приходилось бы "ветвить" свой код почти как здесь:

```js
fs.readFile('movie.mp4')
  .then(function(data) {
    // сделать что-то с data
  })
  .error(function(error) {
    // обработать ошибку
  });
```

Это добавляет ненужную сложность, что понравится не каждому. Вместо двух отдельных функций в Ноде используется единая колбэк-функция. Для неё действуют правила:

- Когда ошибки нет, первым аргументом идет null
- Когда ошибка есть, передавать её первым аргументом
- Остальные аргументы могут использованы как угодно (обычно, это будут данные или ответы на запросы, ведь Нода по большей части работает с вводом/выводом)

Отсюда и такой стиль написания колбэков:

```js
fs.readFile('movie.mp4', function(err, data) {
  // обрабатываем ошибку и делаем какие-то действия с data
})
```

#### Threads/fibers/non-event-based concurrency solutions

Замечание: Если вы ещё не сталкивались с этими терминами, возможно, вам будет проще освоить Ноду, ведь забыть что-то так же сложно как и запомнить.

Чтобы делать всё быстро Нода использует внутри себя потоки (threads), но сама скрывает их от пользователя. Если вы технарь, и вам интересно как устроена Нода внутри, вам совершенно точно надо прочитать об [архитектуре библиотеки libuv](http://nikhilm.github.io/uvbook/), C++ I/O слое, на котором держится сама Нода.

### Источник

Данный материал основан на [art-of-node](https://github.com/maxogden/art-of-node), созданном [Max Ogden](https://github.com/maxogden).

Спасибо за перевод Andrey Safronov и bereg_73. Сам перевод [тут](https://github.com/maxogden/art-of-node/blob/master/readme.ru.md).

Делал ревью и добавлял кучу правок [vladthelittlone](https://github.com/vladthelittleone).
