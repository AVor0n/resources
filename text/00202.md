## Вложение (Embedding)

Язык Go не поддерживает типичное управление типов подклассов, но он имеет возможность "заимствовать" части реализации с помощью типа *вложения* структуры или интерфейса.

Вложение интерфейса необычно простое.
Мы уже упоминали об интерфейсах `io.Reader` and `io.Writer` ранее, вот их определение.

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Пакет `io` также экспортирует несколько других интерфейсов, которые определяют объекты, которые могут реализовывать несколько таких методов.
К примеру, `io.ReadWriter` содержит оба интерфейса `Read` и `Write`.
Мы может указать `io.ReadWriter` перечислением двух методов в явном виде, но проще и более запомяющим будет встраивание двух интерфейсов в одну новую форму, вот так:

```go
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
```

Это выглядит следующим образом: `ReadWriter` может делать все что делает `Reader` **и** что делает `Writer`. Это объединение встраивания интерфейсов (которые не имеют пересечений в методах).
Только интерфейсы могут встраивать интерфейсы.

Аналогичная идея используется для структур, но с большим количеством последствий. Пакет `bufio` имеет две структуры типов - `bufio.Reader` и `bufio.Writer`, каждая из которых реализует аналогичные интерфейсы как в пакете `io`. И `bufio` также реализует буферизованное чтение/запись, которое объединяет чтение и запись в одну структуру с использованием вложения: этот список типов структур, но не давая имена полям.

```go
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
```

Вложение указателей элементов в структуры и конечно должно быть инициализировано необходимой структурой до его использования.
Структура `ReadWriter` может быть записана так:

```go
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
```

**TODO**
but then to promote the methods of the fields and to
satisfy the `io` interfaces, we would also need
to provide forwarding methods, like this:
**-**


```go
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
```

Для непосредственного вложения структур, мы должны избегать эту бухгалтерию.
Метод вложенного типа приходит свободно, что означает что `bufio.ReadWriter` имеет не только его методы `bufio.Reader` и `bufio.Writer`, а также удовлетворяет всем трем интерфейсам:
* `io.Reader`,
* `io.Writer`, и
* `io.ReadWriter`.


Это важное отличие вложения от подклассов. Когда мы вкладываем тип, методы этого типа становятся методами внешнего типа, но для получателя они вызываются как встроенные типы, а не внешние.
В нашем примере, когда метод `Read` из `bufio.ReadWriter` вызывается, он и вызываются также как описано выше; получатель поля `reader` из `ReadWriter`, является самим `ReadWriter`.

Вложение может быть простым и удобным.
Этот пример показывает вложение поля рядом с именованным полем.

```go
type Job struct {
    Command string
    *log.Logger
}
```

Тип `Job` сейчас имеет `Log`, `Logf` и другие методы `*log.Logger`.
Мы могли бы дать имя для `Logger`, конечно же, но в этом нет необходимости. И сейчас, мы можем логировать `Job`:

```go
job.Log("starting now...")
```

Регулярное поле `Logger` в структуре `Job`, поэтому мы можем инициализировать его как обычно внутри конструктора `Job`, вот так:

```go
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
```

или с помощью составных литералов:

```go
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
```

Если нам необходимо обратиться непосредственно к вложенному полю, имени типа поля, игнорируя пакетный классификатор, как к имени поля, как это сделано в методе `Read` в нашей структуре `ReaderWriter`.
При этом нам необходим доступ к ` * log.Logger` в `Job` переменной `job`, мы можем написать `job.Logger`, что полезно если мы хотим уточнить методы `Logger`.

```go
func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
```

Вложение типов создает проблему конфликта имен, но правила для их решения просты.



Первое, поля или метод `X` скрывает любой иной элемент `X` в более глубокой части вложенного типа.
Если `log.Logger` содержит поле или метод под названием `Command`, то поле `Command` в `Job` будет преобладать над ним.


Во-вторых, если есть одинаковые имена на том же уровне вложенности, это как правило ошибка и было бы ошибочно вставлять `log.Logger`, если структура `Job` имеет другое вложенное поле или метод с названием `Logger`.
Однако, если дублированные имена никогда не встречается в программе вне определённого типа, то это нормально.
Это защищает от изменения типов вложенности за его пределами; и это не проблема, если добавлено поле вступающее в конфликт с другим полем в другом подтипе, если ни одно из полей не используется.
